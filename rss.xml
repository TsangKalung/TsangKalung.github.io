<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Tsang's Blog]]></title><description><![CDATA[Tsang's Blog]]></description><link>https://tsangkalung.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 29 Nov 2020 08:37:22 GMT</lastBuildDate><item><title><![CDATA[【WIP】译文：Static TypeScript，TypeScript 的一种静态编译器实现]]></title><description><![CDATA[译者声明：本译文获得原作者授权翻译。 作者： Thomas Ball，微软研究院，Redmond，tball@microsoft.com Peli de Halleux，微软研究院，Redmond，jhalleux@microsoft.com Michał Moskal…]]></description><link>https://tsangkalung.github.io/static-ts/</link><guid isPermaLink="false">https://tsangkalung.github.io/static-ts/</guid><pubDate>Mon, 23 Nov 2020 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;译者声明：本译文获得原作者授权翻译。&lt;/p&gt;
&lt;p&gt;作者：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Thomas Ball&lt;/strong&gt;，微软研究院，Redmond，tball@microsoft.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peli de Halleux&lt;/strong&gt;，微软研究院，Redmond，jhalleux@microsoft.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Michał Moskal&lt;/strong&gt;，微软研究院，Redmond，mimoskal@microsoft.com&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;综述&lt;/h2&gt;
&lt;p&gt;基于单片机的嵌入式设备通常使用 C 语言进行编程。这类设备如今进入了计算机科学教学的课堂，甚至一些中学也开办了相关的课程。于是，用于单片机编程的脚本语言（如 JavaScript 和 Python）使用也逐渐增加。&lt;/p&gt;
&lt;p&gt;我们研发了 Static TypeScript（STS），它是 TypeScript 的一种子集（而 TypeScript 本身是 JavaScript 的超集），还研发了相关的编译/链接工具链，它们全部使用 TypeScript 进行开发并且在浏览器中运行。STS 为实践而设计（特别是实践教学），适合针对小型设备的静态编译。用户编写的 STS 程序将在浏览器中被编译成机器码，并链接预编译的 C++运行时，生成比普通的嵌入式解释器更高效的可执行文件，从而延长电池寿命并可以在 RAM 低达 16kB 的设备上运行（例如 BBC micro:bit）。本论文主要对实现 STS 系统和适用于课堂教学的嵌入式编程平台的技术挑战进行综述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;JavaScript，TypeScript，编译器，解释器，单片机，虚拟机&lt;/p&gt;
&lt;h2&gt;1 简介&lt;/h2&gt;
&lt;p&gt;近来，课堂上计算机的实物教学不断地发展，鼓励孩子们构建自己的简单的交互嵌入式系统。例如，图 1（a）展示了 BBC micro:bit[1]，它是一种受 Arduino 启发的小型可编程计算机，拥有集成的 5X5 LED 显示点阵、几个传感器和低功耗蓝牙（BLE）无线传输。该设备与 2015 年首次向英国所有 7 年级学生推出（10 至 11 岁），随后走向全球，迄今为止已经通过 micro:bit 教育基金会（ &lt;a href=&quot;https://microbit.org&quot;&gt;https://microbit.org&lt;/a&gt; ）发放了四百万个设备。图 1（b）则展示了另一个以 RGB LED 为特点的教育设备 Adafruit’s Circuit Playground Express (CPX)。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a99b064967e9368263d4f1bb52ca18e4/6c68b/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACl0lEQVQoz42T30uTURjH9590E12YqdgPIeb8semmU+fUaalzS53OX8nMJHelqERu60YDLZWEAgMLIrop6CI0KPBCSCIMSafl3HRb5tja3vfT66YTu+rAOZzzvN/n85xz3u+RIYr8TxMlnSAIybnf7yO460WIRhIxQYzHZTFpOPjpJ7zmJez249nysLrlZnvHh8e3h3c3QCgckcQJWGDXx6vn09x39jHvGOHF6CAb66vJQrLIQYRvheM4r3TSW9CJSdNEW5EFVXEteaVGspSVjE09iSf83vfjHLnNgNVArTqb3Avp9Gmq6Kkz8n11Ja6RRQIhbHIL57LUpOWVUVRQj7XQilxpIDO3nLNpedgHXXHx29fzWLs0mOpUKDIvcTklBUNuKd3ydiaG7yISQ+bdC6A3WVGV1pOVX4ne2EbBtUaKq5u5qqlBV9yAwzUZB05MOqiyVdBjs1BZqqVMXUSdwUB7pZ3+jiF8O25kHumOWpq70FcYycwpR2toQlNxg0K9iRzp2CW6Glzjj+LAmSkXyg49umo9WqWKfEU+NdoS6s3j9NucBPd+SEBphypFFecvakiTl6CWYPllRgr05niBM6kKuu8Mx4GfFt6hszWRWl1LlaEBvbac9LybZJU5mHgwk7hDn/TX7g1102KpZXigF3OjiZEhO5bWZgYH7XR2mnk2N0VMOLRGjKczY1Tf6iejyExGWjbKplHsUsHg7nYCGA4f4F6e5eviGOvL83z58JjNzy9ZWZxlbWmOlfcuNlffcOJWkaWPC7S0dmG83sz0xEPEaOjENoe+jkZF/kRjRKVtBH/ts7HhlubSOprogiAmE47BAb+fzU33KeMfAU+/lFAohMfj+fedJBOO9cFgEK/XdxQTkt/+AjhFnH73LZBpAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;图1&quot;
        title=&quot;图1&quot;
        src=&quot;/static/a99b064967e9368263d4f1bb52ca18e4/fcda8/1.png&quot;
        srcset=&quot;/static/a99b064967e9368263d4f1bb52ca18e4/12f09/1.png 148w,
/static/a99b064967e9368263d4f1bb52ca18e4/e4a3f/1.png 295w,
/static/a99b064967e9368263d4f1bb52ca18e4/fcda8/1.png 590w,
/static/a99b064967e9368263d4f1bb52ca18e4/efc66/1.png 885w,
/static/a99b064967e9368263d4f1bb52ca18e4/c83ae/1.png 1180w,
/static/a99b064967e9368263d4f1bb52ca18e4/6c68b/1.png 1888w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 1&lt;/strong&gt; 两个 Cortex-M0 的单片机教育设备：(a) BBC micro:bit 拥有包含 16kB RAM 和 256kB 闪存的 Nordic nRF51822 微控制单元；(b) Adafruit’s Circuit Playground Express ( &lt;a href=&quot;https://adafruit.com/products/3333&quot;&gt;https://adafruit.com/products/3333&lt;/a&gt; ) 拥有包含 32kb RAM 和 256kB 闪存的 Atmel SAMD21 微控制单元。&lt;/p&gt;
&lt;p&gt;研究表明在计算机科学教育中使用这样的设备会增加对孩子们的吸引力，尤其是对于女生，还可以增加孩子们和老师们的自信，让课堂教学更加生动[2,16]。&lt;/p&gt;
&lt;p&gt;为了控制课堂教学的成本，这些设备一般使用 16 到 256kB 的 32 bit ARM Cortex-M 单片机，使用额外的计算机（通常是笔记本电脑或台式机）进行编程。在课堂上用这类设备进行编程教学有一系列技术挑战：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;选择/设置合适该年龄段学生的编程语言和开发环境&lt;/li&gt;
&lt;li&gt;教室的计算机使用的操作系统通常是过时的，互联网连接也不稳定或速度慢，并且可能被学校的 IT 管理员限制访问外部网络，这使得安装原生应用程序有种种困难&lt;/li&gt;
&lt;li&gt;学生开发的程序要从计算机转移到电池供电的嵌入式设备上（正如很多项目都在实验中提供这种设备，若没有提供也可以“改造”。）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;面对这些挑战，有许多流行脚本语言的嵌入式解释器应运而生，例如 JavaScript 的 JerryScript[8,15]、Duktape[22]、Espruino[23]、mJS[20]、MuJS[19]，Python 的 MicroPython[9]及其分支 CircuitPython[12]。这些解释器直接在微控制器上运行，仅依赖从计算机向嵌入式设备传输程序文本；但它们也舍弃了深度优化的 JIT 编译器（如 V8）的一些优势，这类编译器运行需要的内存比单片机的内存要大两个数量级。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/27284f7d8f183b0570238d2ea92da2f3/669eb/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 93.24324324324323%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAFNUlEQVQ4yx2TeVCUZQDGvyZvMgyLxKw8mnQmJ7UyPDiazKvUhFGsFFwQUJZDglRuUQivPFBTKAURFEniFDnk3F1g2ZM9WBZYjkBFG83Of5rq14t/PDPffO/M73ue93k+6cFgNw+HeoR6GR2w8/vDYU4d+xqNop5HIw5Gei1CZobtRkZ6TNzt0mBquUWPVTw7bNzr78OhqcOqbmC4pxPp/kD3U9D9fnHo6OLxXQe7ZDsoyMnml3v9DHTpGezSMWTVcd9uwpEnpynMFfPlCHpL0hj6MRFz4hxuJPtitxiQ7jmsjOlun3DSZ2Wg24S3lwfpBxN5PCK+btEyYNEwYtMzrK1n+OAsSna/ybFIHxIi/EmN+pyG6HnUxryFulWFNNw3Zt3CYLfxabwhEc/rA28OJSfwcNCGTafEpm1hWEB/UlcxHP8i70ddRDoO49L+REr8jwMRMpoPLEav0SD1WrWkpKYRHhmFn7+c4O1h7ItMIb+gjnNZ5eJ9LOs3+pJ74Syj+jp697vy9t6rSKn/MDHhEZJ8iMOBa2hO9sBkEJFt+g681vuxePlHuG/ZzTtXq1hSZWRJUz/vHMxmxXJvps9fSXJcPA+M9Zj2v86mj32Y/8FeFnnKWLgikKwtbjSkb8JmMSHZOzUEh4WxbtWHrIrP4LknIA3+gTQKTpk/4PHWbBYt8yIlPp57uhr6k2aTvXky1QGT6ZRPoErmhCJoHE3no+m3WwTQoMZ3p5yAoHAycm6y9+Ff7Bz9jS9+/Rfv8wW8u2A2zm+sRB55gCfGKnJl8zjrO51TPi9TGOjKEZ8ZXN06BfW1DBzdAtilbyUh/RTp32Rx+nw2+zOzCM24hF9qIWv9E1nutY5XFq0WwP08UJehjZ7J6U3OlMteEJrGte0ujMaOR3UjkwG7VZRiVqNUNHI2K5dd8hjWbgjA+5Molq5JYunqvSxY/ikLl60jLTWFvo468iPcSdngxgm/OWRsnknaRje+D1mCRVklNmtE6jG1YzW00dZ8h+qKH6mvvU3N7Uqqb5Vyq6KMsrIKSksrUbU0Y9RqKC8rpbAgj7If8ikvLqS48Co1lSX0i732mzuQrIZ2zCJ2d2cbFp2C2mtHUFyOpO5iOHVnd1J/xo+6kz5UHd1IRcYGak5u4/bRreQd2UPGV35UFF0Sv5wRu7EVh1ns0KIfA6qwirbbq/NpiHsV26Fp6OJEk7GzuBj2HmfC3DkV7sHxUHeKwl9DGTWBzJCFZPpJZKWH0ms10COAfWYtUqeuFZNwZhZtW+5cYfDrl9m3eS6VweM4lBiCFPsb0u4RpC//RvKtI+xDF1QJU7kudyb3s/FcObobe5dBOFTRZxKRjRoVnR0CqG2nqzGPAz5zCV49lxDPaewKD2JCGjwf8zNOKTAxUEuwpxN5oS9R8PkMzi114tvkQHoE0KpX0tupRtKrFRjULZgEUF+TQ2WEC194v0qmz7Mci9vKlIS7PL+vl6lJ95n0WSE7vKdRHODGhTWulMrHc+lwAN1mPRa9QsRuQ9K1NaNra8LY0Yq2Ogd70kSuBztTGzWF/NglRO/4iHiZJ8lBnsT4exAX5E7eHmdywl0o2fMMWcl+2EwGzOLabGItkkbVyJgMaiUt1Tf4LtiVmzsnUySbxJXIBZzwn0dN+LNURU6gLMaNpBBvDm+bTnG0K2dkLlw4HiOAejEpcW36MaDyDhplA9rWJjqU9dSX56IozUZZfhnV7esoqotoq75GW00h7bWFaOqLMTUVYWy8ibqhBH17M52iB5NWKVwq+R/xGA/Jz0X2dAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/static/27284f7d8f183b0570238d2ea92da2f3/fcda8/2.png&quot;
        srcset=&quot;/static/27284f7d8f183b0570238d2ea92da2f3/12f09/2.png 148w,
/static/27284f7d8f183b0570238d2ea92da2f3/e4a3f/2.png 295w,
/static/27284f7d8f183b0570238d2ea92da2f3/fcda8/2.png 590w,
/static/27284f7d8f183b0570238d2ea92da2f3/efc66/2.png 885w,
/static/27284f7d8f183b0570238d2ea92da2f3/c83ae/2.png 1180w,
/static/27284f7d8f183b0570238d2ea92da2f3/669eb/2.png 1244w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 2&lt;/strong&gt; 三款有 160x120 分辨率彩色屏幕的基于单片机的游戏机，这些开发板使用 ARM 的 Cortex-M4F 核心：ATSAMD51G19（192kB RAM，以 120Mhz 主频运行）和 STM32F401RE（96kB RAM，以 84Mhz 主频运行）。&lt;/p&gt;
&lt;p&gt;很不幸的是，这些嵌入式解释器都比 V8 慢几个数量级（详细对比见第 4 节），影响响应速度和电池寿命。更重要的是，由于内存中的对象表示为动态键值映射（dynamic key-value mappings），因此它们的内存占用量可能是实现同样功能的 C 程序的几倍，这一点严重限制了程序在更低内存的机器上(如 16kB RAM 的 micro:bit 和 32kB RAM 的 CPX)运行的可能性。&lt;/p&gt;
&lt;h3&gt;1.1 Static TypeScript&lt;/h3&gt;
&lt;p&gt;作为上述嵌入式解释器的替代，我们开发了 Static TypeScript（STS），它是 TypeScript 的语法子集[3]，由一个用 TypeScript 编写的编译器支持，该编译器可以生成在 16-256kB RAM 的微控制器上高效运行的机器码。STS 及其编译器和运行时的设计主要着力于解决前文提到的三个挑战。确切来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;STS 削除了 JavaScript 大部分的「糟粕」；受 StrongScript 影响[14],对于静态声明的类，STS 使用名义类型（nominal type），并支持用虚拟函数表的经典技术对类进行高效编译。&lt;/li&gt;
&lt;li&gt;STS 工具链是离线运行的，一旦加载入浏览器，就不再需要 C/C++编译器。它们用 TypeScript 实现，将 STS 编译为 ARM Thumb 机器码并在浏览器中将其与预编译好的 C++ 运行时链接————浏览器或许在大多数时候是课堂中唯一可用的运行环境了。&lt;/li&gt;
&lt;li&gt;令人惊喜的是，STS 编译器生成的机器码高效而紧凑，使得我们解锁了一系列应用领域，例如图 2 中所示的低配置设备的游戏编程，它们能够运行全都得益于 STS 提供的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;将 STS 用户程序部署到嵌入式设备不需要安装特别的应用或设备驱动，只需要进入浏览器即可。完成编译的程序以文件下载的形式显示，然后用户将文件传输到显示为 USB 存储器的设备中即可（或者直接通过 WebUSB 协议传输，它是一种即将推出的将网站与物理设备连接的协议）。&lt;/p&gt;
&lt;p&gt;STS 简单编译的编译方案（将在第 3 节详述）在一系列小型 JavaScript 基准测试中取得了惊人的优秀表现，性能可以和 V8 等先进前沿的 JIT 编译器媲美，而所需的内存则比他们低几个数量级（详情见第 4 节）；同时，也比嵌入式解释器快至少一个数量级。评估的一个特别之处是对处理类、接口和动态映射（dynamic maps）的字段/方法查找的不同策略的比较。&lt;/p&gt;
&lt;h3&gt;1.2 MakeCode：为教学而生的简单嵌入式开发&lt;/h3&gt;
&lt;p&gt;STS 是 MakeCode 框架（详情见 &lt;a href=&quot;https://makecode.com&quot;&gt;https://makecode.com&lt;/a&gt; ；该框架及诸多编译器已按 MIT 协议开源，请见 &lt;a href=&quot;https://github.com/microsoft/pxt&quot;&gt;https://github.com/microsoft/pxt&lt;/a&gt; ）支持的核心语言。MakeCode 支持为单片机设备创造自定义的嵌入式编程实验。每个 MakeCode 实验（我们一般称其为编辑器（editors），虽然它们也包含了模拟器、API、教程、文档等）通过 STS 针对特定设备或设备类型进行编程。&lt;/p&gt;
&lt;p&gt;大多数 MakeCode 编辑器主要以 Web 应用的形式部署，其中包含了用以开发 STS 程序的功能齐全的文本编辑器，它基于 Monaco（VS Code 使用的编辑器组件）；还包含了基于 Google Blockly 框架的图形化编程界面（注释中的 STS 元数据定义了 STS 的 API 到 Blockly 的映射，MakeCode 会在 Blockly 和 STS 之间进行交互）。&lt;/p&gt;
&lt;p&gt;MakeCode 编辑器和原先 BBC micro:bit 和 Adafruit CPX（详情见 &lt;a href=&quot;https://makecode.microbit.org/&quot;&gt;https://makecode.microbit.org/&lt;/a&gt; 和 &lt;a href=&quot;https://makecode.adafruit.com/&quot;&gt;https://makecode.adafruit.com/&lt;/a&gt; ）的编程实验至今已经覆盖了全球的数百万学生和教师。&lt;/p&gt;
&lt;p&gt;STS 支持包（package）的概念，即 STS、C++、汇编代码文件的集合，并支持把其他的包当做依赖。第三方开发者已经利用这样的能力对 MakeCode 编辑器进行扩展，使之可以支持各种开发板的外接设备（micro:bit 的相关示例见 &lt;a href=&quot;https://makecode.microbit.org/extensions&quot;&gt;https://makecode.microbit.org/extensions&lt;/a&gt; ）。值得注意的是，大多数包完全用 STS 编写从而避免了不安全 C/C++的陷阱，这主要得益于高效的 STS 编译器以及通过数/模针脚（GPIO、PWM、servos）和一些协议（I2C 和 SPI）访问硬件的底层 STS API。&lt;/p&gt;
&lt;p&gt;图 3 展示了用来为图 2 中的手持游戏设备进行编程的 MakeCode Arcade 编辑器（事实上，图中编辑器里的 STS 程序就是在三个单片机设备中运行的游戏之一，它是一个简单的平台游戏）。MakeCode Arcade 包含了一个大部分由 STS 编写的游戏引擎，因此对代码运行效率提出了很高的要求，因为要在高帧率下实现令人快活的视觉效果。该游戏引擎包含游戏循环逻辑、事件上下文栈、物理引擎、文字线条绘制等模块以及用于特定游戏的框架（比如，为图中的平台游戏（译者注：platformer games，这是一种游戏类型）），游戏引擎一共由一万行 STS 代码和少数最基础的 C++ 图像模糊函数组成。该游戏用 Arcade 构建，在浏览器（桌面或移动端）运行，或在不同型号但符合配置要求的单片机上运行（160*120 像素 16 色屏幕和 100MHz 左右主频、100kB RAM 左右的微控制器）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 3&lt;/strong&gt; MakeCode Arcade 编辑器。左边的面板是 Arcade 设备的模拟器；中间的面板是编辑器中可用的 API 的目录；右边的面板是 Monaco 编辑器，可用在其中用 STS 代码为平台游戏编程（ &lt;a href=&quot;https://makecode.com/85409-23773-98992-33605&quot;&gt;https://makecode.com/85409-23773-98992-33605&lt;/a&gt; ）。位于顶部的开关用来在模块可视化编程和 Static TypeScript 编程面板之间切换（由于市场因素，被标记为 JavaScript）。&lt;/p&gt;
&lt;p&gt;本文的主要目的是详述了该广泛应用的系统和解决上述课堂教学难题的方法。&lt;/p&gt;
&lt;h2&gt;2 Static TypeScript(STS)&lt;/h2&gt;
&lt;p&gt;TypeScript[3]是 JavaScript 的渐进式[18]超集。这意味着所有 JavaScript 程序都是 TypeScript 程序并且其类型是可选的、按需添加的，这些类型可以让 IDE 提供更好的支持，也能让大型 JavaScript 程序有更好的错误检测（error checking）。对象类型提供了映射（maps）、函数和类的统一形式。对象类型之间的结构子类型（structural subtyping）定义了可替换性（substitutability）和兼容性检查。经过类型擦除（及较小的语法转换）后生成原始的 JavaScript 程序。&lt;/p&gt;
&lt;p&gt;STS 是 TypeScript 的子集，TypeScript 继承了 JavaScript 的一些高度动态化的语法：&lt;code class=&quot;language-text&quot;&gt;with&lt;/code&gt;语句、&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;表达式、基于原型的集成、类之外的&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;指针、&lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;关键字、&lt;code class=&quot;language-text&quot;&gt;apply&lt;/code&gt;方法。STS 保留了诸如动态映射（dynamic maps）的特性，但将它们与名义类抽象分开。这样的限制是可以接受的，因为大多数初学者编写的程序都非常简单，而且嵌入式领域的 JavaScript 或 TypeScript 库非常少，所以使用这些被限制的 JavaScript 特性（如猴子补丁，monkey patching）的机会很少。&lt;/p&gt;
&lt;p&gt;我们的目标并不是让 STS 支持 TypeScript 的全部功能，而是务实地聆听用户需求，按嵌入式编程所需添加语言特性。&lt;/p&gt;
&lt;p&gt;与所有对象类型都是属性包的 TypeScript 相比，STS 在运行时拥有四种不相关的对象类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;动态映射&lt;/em&gt;类型，它具有命名属性（即字符串索引），能保存任何类型的值&lt;/li&gt;
&lt;li&gt;&lt;em&gt;函数&lt;/em&gt;（闭包）类型&lt;/li&gt;
&lt;li&gt;&lt;em&gt;类&lt;/em&gt;，用以描述类的示例，通过访问每个字段/方法进行高效的运行时子类型检查，对它们进行名义上的处理，后文中会详述&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数组&lt;/em&gt;（集合）类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;某种程度上，STS 与 Java 和 C# 的风味更接近，它们都把类型视作「抽象的守护神」（protectors of abstractions），而不像 JavaScript 那样允许更加自由地处理对象。在 3.4 节的讨论中，运行时类型标签（type tags）用于区分上面列出的不同种类的内置对象类型（以及诸如装箱数字（boxed number）和字符串之类的语言基础构件）。&lt;/p&gt;
&lt;p&gt;与 TypeScript 中一样，类型转换不会生成任何代码且不会失败。相反，STS 在字段/方法访问点保护名义上的类抽象。当&lt;code class=&quot;language-text&quot;&gt;x == null&lt;/code&gt;时，&lt;code class=&quot;language-text&quot;&gt;x.f&lt;/code&gt;在 JavaScript 中会导致运行时错误。如果&lt;code class=&quot;language-text&quot;&gt;T&lt;/code&gt;是具有字段&lt;code class=&quot;language-text&quot;&gt;f&lt;/code&gt;的类，并且&lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;的动态类型不是&lt;code class=&quot;language-text&quot;&gt;T&lt;/code&gt;的名义子类型，则&lt;code class=&quot;language-text&quot;&gt;(x as T).f&lt;/code&gt;在 STS 中将导致运行时错误。如果&lt;code class=&quot;language-text&quot;&gt;T&lt;/code&gt;是接口、&lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;或某种复杂类型（例如，union 或 intersection），则与&lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;的动态类型无关，而是根据名称查找该字段。&lt;/p&gt;
&lt;p&gt;其他抽象在运行时中也受到保护，正如在 JavaScript 中那样：例如，对非&lt;em&gt;函数&lt;/em&gt;类型的对象进行函数调用。现在，将属性动态添加到除&lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt;类型之外的任何其他类型是错误的。我们将来可能会取消对动态 JavaScript 语义的限制，这取决于用户的反馈。迄今为止，在我们的用户社区（教育工作者和开发人员）中还没有收到任何关于这些限制的负面反馈。&lt;/p&gt;
&lt;p&gt;STS 基本类型根据 JavaScript 语义进行处理。特别要强调的是，所有的数字类型在理论上都是 IEEE 64 位浮点类型，但也有可能实际使用 31 位带符号标记的整数类型。运算符的实现（例如加法或比较）基于动态值的分支，以遵循 JavaScript 语义，并在汇编中手动实现了整数类型的快速实现。&lt;/p&gt;
&lt;p&gt;STS 既是 TypeScript 的语法子集又是语义子集，这意味着，如果程序在 STS 中成功编译，它将具有与等效 TypeScript 程序相同的语义，否则该程序会在运行时崩溃（在上述情况下）。&lt;/p&gt;
&lt;h3&gt;2.1 与 C++ 进行交互操作&lt;/h3&gt;
&lt;p&gt;STS 程序运行在单片机上由 C++、C、汇编实现的运行时里。该运行时实现了语言的基础构件（操作符、集合、类的支持、动态映射等），同样也支持对底层硬件的访问。该运行时能用包进行拓展，相关详情见 2.2 节。&lt;/p&gt;
&lt;p&gt;STS 支持调用 C++ 函数，反之，亦可以从 C++ 调用 STS 函数。为了简化这个过程，STS 使用了一直能够简单的代码生成策略，即在 C++ 函数中使用特殊的注释（&lt;code class=&quot;language-text&quot;&gt;//%&lt;/code&gt;）指定那些代码需要导出为 STS，这样的策略还用于导出为 Blockly 代码块（使用注释&lt;code class=&quot;language-text&quot;&gt;//% block&lt;/code&gt;）。构建中有一个步骤是解析 C++代码获取这些特殊的注释，还会收集这些函数的原型（签名），从而在调用它们时可以生成正确的转换。举个转换的例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// C++源码:&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; control &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;/** Register an event handler */&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//% block&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; eventType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Action handler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// arrange for pxt::runAction0(handler)&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// to be called when eventType is triggered&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 生成的TypeScript&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; control &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;/** Register an event handler */&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//% block shim=control::onEvent&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventType&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C++ 的命名空间和函数名直接映射到 STS 对等的代码上，原先的代码文档注释也会对应复制。注释&lt;code class=&quot;language-text&quot;&gt;//% block&lt;/code&gt;指定函数暴露为 Blockly 图形代码块，它也会被复制。还有许多其它可能的注释可以控制等效图形的外观。STS 函数还会有一个附加的&lt;code class=&quot;language-text&quot;&gt;shim&lt;/code&gt;注释，标注对应的 C++ 函数名（某些情况下，STS 声明是用用户编写的，这时候 C++ 函数名不必与 STS 函数名对应）。
C++ 的类型会映射到 STS 的类型，由于在 STS 中所有数字类型理论上都是双精度的（），所以 C ++ 的&lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt;类型会映射到 STS 的&lt;code class=&quot;language-text&quot;&gt;number&lt;/code&gt;类型。当 C++ 函数被调用时，STS 编译器会确保被传递的值被转换为整数。其它的 C++ 整数类型（例如&lt;code class=&quot;language-text&quot;&gt;uint16_t&lt;/code&gt;）也用相似的方法被支持。C++的&lt;code class=&quot;language-text&quot;&gt;Action&lt;/code&gt;类型代表对一个闭包的引用，它将和&lt;code class=&quot;language-text&quot;&gt;pxt::runAction0（）&lt;/code&gt;一起被调用。&lt;/p&gt;
&lt;p&gt;类方法还没有被直接支持，常规的函数能用于实现对象，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; BoxedBuffer &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;Buffer&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; BufferMethods &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//%&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getByte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Buffer self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; self&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;len &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; self&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//% shim=BufferMethods::getByte&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;getByte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有在&lt;code class=&quot;language-text&quot;&gt;BufferMethods&lt;/code&gt;命名空间中的函数都必须将&lt;code class=&quot;language-text&quot;&gt;Buffer&lt;/code&gt;作为第一个参数，并在 STS 这边作为&lt;code class=&quot;language-text&quot;&gt;Buffer&lt;/code&gt;类的成员。当这些成员被调用时，STS 编译器会确认第一个参数不是&lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;并且是&lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt;的子类型。这些接口在概念上可以理解为具有不透明表示形式的不可扩展类，即它们不能由常规类实现，并且成员解析是静态的（static）。选择接口语法是因为 TypeScript 允许用新方法在文件之间扩展接口。如果新方法具有上述的&lt;code class=&quot;language-text&quot;&gt;shim = ...&lt;/code&gt;注释，或者指定了使用 TypeScript 而不是 C ++替换函数的模拟注释，那么我们允许此类添加。这通常只在高级 C++ 包的开发中涉及（见下文）。&lt;/p&gt;
&lt;h3&gt;2.2 包（Packages）&lt;/h3&gt;
&lt;p&gt;STS 支持多种输入文件，也支持 TypeScript 的&lt;code class=&quot;language-text&quot;&gt;namespace&lt;/code&gt;语法用以区分作用域。文件不会引入作用域，并且当前不支持 JavaScript 模块。输入文件可以来自一个或多个&lt;em&gt;包&lt;/em&gt;。其中一个包为主包，可以列出其他包作为依赖关系，而后者又可以列出其他的依赖关系。有多种方法可以指定包的版本，包括内置包、用命令行进行操作时指定文件路径、GitHub 仓库的 URL。使用包时只能用一个版本（否则可能会发生重定义错误）。&lt;/p&gt;
&lt;p&gt;MakeCode 编辑器的构建者通常会决定打包一些随编辑器提供的内置包，这些扩展可以通过 GitHub 中的包进一步扩展。 MakeCode Web 应用程序支持将包发布到 GitHub。 因为命名空间独立于文件，所以包很容易扩展现有的命名空间。目前，STS 不对命名空间名称执行检查。&lt;/p&gt;
&lt;p&gt;MakeCode 附带了许多编辑器构建器可以附带的包（通用包），它们用以支持各种硬件功能（引脚、按钮、蜂鸣器、屏幕等），以及诸如处理 Sprite 的游戏库之类的高级概念。其中一些包是变体，共享界面但具有不同的实现方式（例如，用于不同屏幕的驱动程序）。&lt;/p&gt;
&lt;p&gt;外部（GitHub）包通常为其他硬件拓展设备提供支持。用户通常不会一次使用太多外部包，因此我们感到由于没有让命名空间强制不同名而导致名称冲突的风险很低，并且它允许将新的 API 自然地融入现有的名称空间。&lt;/p&gt;
&lt;h2&gt;3 编译器和运行时&lt;/h2&gt;
&lt;p&gt;STS 的编译器和工具链（链接器等）完全使用 TypeScript 编写。现在尚不支持单独编译 STS 文件，STS 是一个完整的程序编译器（支持缓存预编译的包，其中包含了 C++ 运行时）。STS 的设备运行时主要是由 C++ 编写的，包含定制的垃圾回收器。正如前文提到的，STS 并不计划支持 JavaScript 的全部功能。&lt;/p&gt;
&lt;h3&gt;3.1 编译工具链&lt;/h3&gt;
&lt;p&gt;TypeScript 源程序由常规 TypeScript 编译器处理，执行包块类型检查在内的语法和语义分析；这个过程产出有类型注释的抽象语法树（AST），然后检查是否有 STS 范围之外的构造（类似&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;等）。抽象语法树随后会转化为具有语言构造的自定义 IR 用以调用运行时函数。这种 IR 之后回北转换为下列的三种形式之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继续传递 JavaScript 运行到浏览器中（在单独的 iframe“模拟器”里）。&lt;/li&gt;
&lt;li&gt;与预编译的 C++ 运行时链接的 ARM Thumb 机器码，用以在裸机（A ‘bare-metal server’ is a computer server that is a ‘single-tenant physical server’. The term is used nowadays to distinguish it from modern forms of virtualisation and cloud hosting.）硬件和操作系统内部运行。&lt;/li&gt;
&lt;li&gt;自定义虚拟机的字节码，用于无法加载或生成动态语言的平台（例如 XBox 和 iOS）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ARM Thumb 机器码和自定义的字节码全都被生成为汇编代码，再由定制的汇编器转换为机器码。在本节中我们主要讨论原生 32-bit ARM Thumb 的转化过程（我们会在 4.2 节对比虚拟机的性能）。&lt;/p&gt;
&lt;p&gt;本段提到的常规的 TypeScript 编译器、STS 代码生成器、汇编器（assembler）、链接器（linker）均由 TypeScript 实现并且全部运行在浏览器或命令行中。&lt;/p&gt;
&lt;h3&gt;3.2 链接&lt;/h3&gt;
&lt;p&gt;生成的机器码将与一个预编译的 C++ 运行时链接。C++ 的编译在云上运行，编译生成的运行时缓存在 CDN 和浏览器中（可以选择使用所有 C++源码的强哈希算法进行缓存）。通常来说，用户编写他们的程序时，C++ 运行时不会更改，从而让离线操作成为可能[5]。&lt;/p&gt;
&lt;p&gt;生成的机器码通常会附加在预编译 C++ 运行时代码的后面，根据目标设备要求的文件格式（特别是 ELF）对生成文件进行一些修补。为了生成代码，汇编器需要运行时函数的地址，这些地址从运行时的二进制文件提取。&lt;/p&gt;
&lt;p&gt;包可能还要包含从运行时中继承出来的 C++ 代码。包含 C++ 的包组合都必须分别进行编译和缓存，这些也都是在云上运行的。到目前为止，这些可能是天量数字的包组合方式还没有出现大问题，因为学生一般不会一次使用很多外部的包，而且我们的经验是，为 MakeCode 编写的包很少使用原生 C++。&lt;/p&gt;
&lt;h3&gt;3.5 算术运算符&lt;/h3&gt;
&lt;p&gt;一些算术运算符被编写为快速整数路径的汇编提高运行速度；以下是运算符&lt;code class=&quot;language-text&quot;&gt;+&lt;/code&gt;的实现：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;assembly&quot;&gt;&lt;pre class=&quot;language-assembly&quot;&gt;&lt;code class=&quot;language-assembly&quot;&gt;_numops_adds:
    ands r2, r0, r1 ; r2 := r0 &amp;amp; r1
    ands r2, #1 ; r2 &amp;amp;= 1
    beq .boxed ; last bit clear?
    subs r2, r1, #1 ; r2 := r1 - 1
    adds r2, r0, r2 ; r2 := r0 + r2
    bvs .boxed ; overflow?
    mov r0, r2 ; r0 := r2
    bx lr ; return
.boxed:
    mov r4, lr ; save return address
    bl numops::adds ; call into runtime
    bx r4 ; return&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它由特别实现的算术运算符有&lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;|&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;&amp;amp;&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;^&lt;/code&gt;和整数转换（调用 C++ 运行时函数时使用）。这些特别的汇编程序比始终调用 C++ 函数要快约两倍。我们在 4.3 节对乘法的性能做了比较。
除此之外的运算符则用 C++ 实现为使用整数、限制范围的数值和其它类型的抽象值的函数。&lt;/p&gt;
&lt;h3&gt;3.6 内置对象（built-in）的表示&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数组（Arrays）&lt;/strong&gt; 和 C++标准向量（vector）类似，但有相对保守的增长策略并且不支持稀疏数组（sparse array）。包括范围检查在内的简单数组访问操作用用汇编实现。设计索引转换和数组增长的情况用 C++ 运行时处理。缓冲区只是具有汇编字节访问器和用 C ++ 实现的许多实用程序函数的内存连续块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串（Strings）&lt;/strong&gt; 会有四种不同的表示，它们的开头都毁有一个虚函数表（v-table）指针。所有的字符串当前被限制为最大占用 65,535 字节的空间。ASCII 字符串（所有在 0-127 范围内的字符）用长度前缀加 NUL 中止的字符数据表示（其内部仍然可以有 NUL，只是为了方便 C++ 函数使用所以添加最后的 NUL）。较短的 Unicode 字符串使用 UTF-8 的可变长度编码，它们拥有不同的虚函数表。索引方法可以即时解码 UTF-8。&lt;/p&gt;
&lt;h3&gt;3.7 窥孔优化&lt;/h3&gt;
&lt;h3&gt;3.8 垃圾回收器&lt;/h3&gt;
&lt;h2&gt;4 性能评估&lt;/h2&gt;
&lt;p&gt;我们在一系列著名的小型性能密集型测试基准中评估了 STS 编译生成的机器码（又可以成为 STS 的虚拟机后端）的性能，并与以下的竞争对手做了对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种用 gcc 编译的纯 C 实现，用来做对比实验的基准（baseline）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Duktape 2.3&lt;/strong&gt;，一种嵌入式 JavaScript 解释器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT.js 1.0&lt;/strong&gt;，JerryScript 的嵌入式 JavaScript 解释器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 3.6&lt;/strong&gt;，寻常、成熟的 Python 解释器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.js 11.0&lt;/strong&gt;，包含了 V8 这种前沿的 JIT 引擎的运行时&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython 1.9.4&lt;/strong&gt;，一种嵌入式 Python 解释器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用三种不同的基于 ARM 的商用嵌入式系统进行测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GHI Brainpad&lt;/strong&gt;，使用 STM32F401RE 芯片, 拥有 96kB RAM、512kB 闪存和主频为 84MHz 的 ARM Cortex-M4F 核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adafruit Pybadge&lt;/strong&gt;，使用 ATSAMD51G19 芯片，拥有 192kB RAM、512kB 闪存和主频为 120MHz 的 ARM Cortex-M4F 核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树莓派 Zero（Raspberry Pi Zero）&lt;/strong&gt;，使用 BCM2835 芯片，拥有 512kB RAM 和恒定主频为 700MHz （关闭动态 CPU 主频调整）的 ARM11 核心。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树莓派可以运行 Node.js，所以超出了我们目标的内存范围，但我们使用它来作为 V8 的性能参考。通常来说，ARM11 核心的内存访问比 M4F 核心（整体 RAM 在性能上与 L1 缓存类似）的访问速度慢。M4F 核心上的 FPU 只是单精度的，所以么有用于基准测试。我们使用了 ARM11 上的 FPU。&lt;/p&gt;
&lt;p&gt;Duktape 使用 BCM 上的默认配置进行编译。在 STM 上，使用默认配置会立即耗尽内存，所以我们选用了适用于低内存配置文件（还启用了 fast integer 选项）。我们用的是官方的 ARMv6 Node.js 二进制文件。我们使用了 PiCore Linux 附带的 Python 环境。我们用过。我们使用了 STM32 的官方 MicroPython 二进制文件。&lt;/p&gt;
&lt;h2&gt;4.1 基准测试&lt;/h2&gt;
&lt;p&gt;我们使用下面的一系列基准测试。我们尝试使用在 TypeScript/JavaScript 和 Python 中对等的代码，然后对比运行时间&lt;/p&gt;
&lt;h2&gt;4.2 STS 和 VM 的性能&lt;/h2&gt;
&lt;p&gt;图 4 对比了 STS 和其他环境的性能。我们将 C 程序的运行耗时直接用毫秒列出，其他的耗时则以比 C 程序慢多少的差值列出，以表示对 C 的敬意。&lt;/p&gt;
&lt;h2&gt;5 相关的工作&lt;/h2&gt;
&lt;p&gt;Safe TypeScript[13]和 StrongScript[14]都通过运行时类型检查支持了完整的 TypeScript 的类型系统。我们的工作最接近 StrongScript，因为 STS 使用类的名义解释（nominal interpretation）进行代码生成，且 STS 运行时会区分动态对象和类对象，分别生成 JavaScript 的&lt;code class=&quot;language-text&quot;&gt;{x=...}&lt;/code&gt;语法和&lt;code class=&quot;language-text&quot;&gt;new C(...)&lt;/code&gt;语法。&lt;/p&gt;
&lt;p&gt;STS 和 StrongScript 也有一些区别，首先，StrongScript 的类型&lt;/p&gt;
&lt;h2&gt;6 总结&lt;/h2&gt;
&lt;p&gt;Static TypeScript（STS）填补了嵌入式编译器中有趣的空白。STS 的工具链完全由 TypeScript 实现，使之可以在浏览器运行并能为覆盖大部分 TypeScript 功能的子集成成 ARM（Thumb）机器码。STS 利用类的名义类型解释（nominal interpretation）提高编译代码的效率。有赖于 MakeCode，STS 现已广泛运行在许多低 RAM 的设备上。一组对 STS 的小型基准评估表明，STS 生成的代码比各种脚本语言的嵌入式解释器的运行速度要快得多。迄今为止最大的 STS 应用程序是 MakeCode Arcade，其游戏引擎有超过 10,000 行 STS 代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;致谢&lt;/strong&gt; 我们要感谢 MakeCode 团队的成员和前成员：Abhijith Chatra、Sam El-Husseini、Caitlin Hennessy、Steve Hodges、Guillaume
Jenkins、Shannon Kao、Richard Knoll、Jacqueline Russell、Daryl Zuniga。我们还要感谢 Lancaster 大学的 James Devine 和 Joe Finney，他们开发的 CODAL 是 STS 的 C++运行时的一部分。最后，我们还要感谢匿名审稿人的评论，并感谢 Edd Barrett 帮忙润色本文的最终版本。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1]: Jonny Austin, Howard Baker, Thomas Ball, James Devine, Joe Finney,Peli de Halleux, Steve Hodges, Michal Moskal, and Gareth Stockdale. 2019. The BBC micro:bit – from the UK to the World. Commun. ACM(to appear) (2019).&lt;/p&gt;
&lt;p&gt;[2]: BBC. 2017. BBC micro:bit celebrates huge impact in first year, with 90% of students saying it helped show that anyone can code. &lt;a href=&quot;https://www.bbc.co.uk/mediacentre/latestnews/2017/microbit-first-year&quot;&gt;https://www.bbc.co.uk/mediacentre/latestnews/2017/microbit-first-year&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[3]: Gavin M. Bierman, Martín Abadi, and Mads Torgersen. 2014. Understanding TypeScript. In ECOOP 2014 - Object-Oriented Programming - 28th European Conference, Uppsala, Sweden, July 28 - August 1, 2014.Proceedings. 257–281. &lt;a href=&quot;https://doi.org/10.1007/978-3-662-44202-9_11&quot;&gt;https://doi.org/10.1007/978-3-662-44202-9_11&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]: 尽管我们可以使用 Emscripten 或类似的技术在本地对 C++ 进行编译，但编译工具链、头文件和相关的库可能需要数十兆的下载请求，导致浏览器的离线缓存空间紧张。&lt;/p&gt;
&lt;hr&gt;</content:encoded></item><item><title><![CDATA[译文：为什么 ML/OCaml 适用于编译器开发（1998）]]></title><description><![CDATA[作者: Dwight VandenBerghe 电邮地址: dwight@pentasoft.com 日期: 1998/07/28 让我们用“ML”系列来指代 SML 或 Objective Caml 等语言。我是 OCaml 的拥簇，虽然我更喜欢 OCaml…]]></description><link>https://tsangkalung.github.io/ml-writing-compilers/</link><guid isPermaLink="false">https://tsangkalung.github.io/ml-writing-compilers/</guid><pubDate>Tue, 17 Nov 2020 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;作者:&lt;/strong&gt; Dwight VandenBerghe&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电邮地址:&lt;/strong&gt; dwight@pentasoft.com&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日期:&lt;/strong&gt; 1998/07/28&lt;/p&gt;
&lt;p&gt;让我们用“ML”系列来指代 SML 或 Objective Caml 等语言。我是 OCaml 的拥簇，虽然我更喜欢 OCaml 的发行版、工具链和总体实现，但我也同时使用 SML/NJ。在不能使用 OCaml 的情况下，我会很乐意用 SML/NJ 进行开发（我并不青睐 Haskell、Gofer、Hugs 等惰性求值语言；人的喜好不同，有人偏爱延迟求值（Deferred Evaluation），也有人更喜欢严格值传递，我的喜好则属于后者。我喜欢严格求值的清爽和了解每一步动作的便利，这是我为什么放弃 Haskell 的原因）。本文中用 ML 来指代，但同样适用于 OCaml 和 SML/NJ 这一类语言。&lt;/p&gt;
&lt;p&gt;我列出来的这类语言会让编写编译器不再枯燥乏味，反而会变成一件趣事。&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收（GC）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GC 听起来非常基础，但它对有很多较短生命周期的复杂数据结构的程序非常重要。首先，编译器就是一个充满复杂数据结构的程序，如果你喜欢编译器，那你肯定着迷于数据结构。C/C++、Pascal 等语言用智能指针或&lt;code class=&quot;language-text&quot;&gt;malloc&lt;/code&gt;等手段让程序员可以手动进行垃圾回收，程序员也扮演着垃圾清道夫的角色，甚至有时候清道夫的角色会多过程序员的角色。而 ML 或许具有最好的 GC 功能，在实际运用中，ML 的 GC 速度足以与 C++的&lt;code class=&quot;language-text&quot;&gt;malloc/free&lt;/code&gt;匹敌，有时候甚至会更快。在使用 ML 的 GC 时我们不必花费精力，就像在使用 Java 一样，但 Java 的 GC 更慢。ML 的 GC 非常自然、高效、稳定，让我们的开发更加轻松。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优化的尾递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦懂得利用它，就可以编写不占用过多栈空间的快速树遍历。当前，有些 C++编译器（例如 Visual C++ 5）据说已经进行了部分尾递归优化，但不能指望它们（VC 中有许多错误）。ML 非常适合编写递归，又因为编译器中的许多数据结构都能利用递归进行很好的处理，因而 ML 非常适合编写编译器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ML 的数据类型适合编译处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器无需担心&lt;code class=&quot;language-text&quot;&gt;unsigned short&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;signed char&lt;/code&gt;，而可以只使用&lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt;（对字符串也一样）。在 C/C++中，&lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt;被广泛使用，而即使有模板类型，C/C++中的字符串类型也相当糟糕。在开发编译器时我们会遇到算术运算需要比&lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt;范围更大的数值进行运算(例如常量折叠，又或者是把基础数值类型向更精确的类型进行 tokenize，然后再转回原来的形式)，这时候就需要&lt;code class=&quot;language-text&quot;&gt;bignum&lt;/code&gt;了。如果这时候没有&lt;code class=&quot;language-text&quot;&gt;bignum&lt;/code&gt;，那么我们需要自己进行对应的实现，或者用其它的奇技淫巧。（这方面更详细的例子可以参阅了不起的编译器作者 Dave Hanson 写的《C
Interfaces and Implementations》[1]）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ML 的类型构造器非常适合描述类似 AST（抽象语法树）的结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它们实现了 tagged unions（标签联合）[2]，这是一种比 C/C++的 union 小巧而高效的 union 数据类型；它带有标签字段标记 union 中的类型，并且标签字段是强制使用的。在 ML 中，tagged union 与模式匹配一起使用，因此以数据结构为参数的函数的代码可读性会非常好。再结合类型推导和尾递归优化，ML 对采用复杂数据结构的递归函数进行了针对性优化。听起来有些耳熟是吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 被认为是数学家进行自动化定理证明的解决方案，因为这一领域的常用语言（Lisp）具有无类型、危险、灵巧的特性，导致不能确定程序是否能正常工作。ML 对此加上了一些限制来提高效率和安全性；ML 程序不会导致系统崩溃，如果它正确完成了编译，那么它就会正常运行，可以保证不会发生普通的类型错误。比如，&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;是不可变的（immutable），并且只能包含一种类型的元素，因此不必担心意外将整数放入字符串&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;导致字符串&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;出错（就像使用 Scheme 和 Lisp 时常发生的错误）；在 ML 中，我们无法更改&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;中的内容，必须创建一个新&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;进行替换，这使得底层运行时比其他语言中的&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;要快得多，在其他语言中，您必须担心双向链表、破坏性更新等。再搭配上默默工作的快速 GC 系统，这一切是如此的自然…让我们可以早些下班。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ML 是为了单独的应用领域（即自动化定理证明[3]）而设计的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一领域的特点是有庞大、棘手、递归的数据结构，它们有着与之对应的复杂算法。听起来有些耳熟是吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异常处理（Exceptions）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 实现了快速且整洁的异常处理，让开发者在使用它们时没有心智负担。假设要开发一个使用键名的表查找程序，我们会把查询功能代码放在&lt;code class=&quot;language-text&quot;&gt;try&lt;/code&gt;的代码块中并且在&lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;中捕获未查找到键名的异常。这样就不用担心未测试出未查找到键名的情况下程序崩溃，如果真的发生这样的异常，运行时会抛出异常消息并告知异常发生的具体位置。当我们学会使用异常处理后，程序会变得更加容易调试、整洁、鲁棒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类型接口（Type Interface）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常在一千行 ML 代码中我们只需要声明两三个变量。ML 通过如何使用变量来确定类型，它不会像 Perl 那样进行类型推导，它的类型是确定的。我喜欢 OCaml 多过 SML 的其中一个原因是 OCaml 不会进行运算符重载：例如，浮点加法(+.)和整数加法（+）的运算符是不同的。类型接口和运算符重载像是同床异梦的床伴，语言的设计者应该在两者之间做出取舍，而不是同时兼容二者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lex/yacc/burg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 对于这些编译器工具有很好的支持。当开始上手这些工具后，你会发现它们会让许多工作变得更轻松。我不是 Lex 的粉丝，也并不喜欢 lalr(1)多过 ll(k)，但我是一个实用主义者，如果有这样被良好实现的工具我会毫不犹豫地使用。OCaml 和 SML/NJ 都拥有很不错的编译工具实现供开发者使用。像这样提供优良工具链的语言并不多见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;忘了说，OCaml 非常的快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我用 OCaml 编写了一种精算财务建模语言的编译器。它大概有一万行代码，但倘若使用 C++则可能需要两万行以上的代码。它可以在奔腾 200 处理器的机器上在 3 秒内编译现有最大的程序，而大多数程序只需不到一秒就可以完成编译，这使我感到非常惊讶。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持（Support）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其它语言的维护者相比，Inria（Xavier Leroy 和 Pierre Weis 等人）提供了更好的支持。关于语言的疑问通常不会太多，我遇到的一些问题在几天之内就得到他们的支持得以解决，这比 VC++或 Turbo Pascal 的支持快很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;库（Library）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 的标准库包含许多实用的数据结构，比其它语言的相对混乱的标准版更加完整、简洁和实用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块系统（Module System）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 对单独的编译具有优异且设计优良的支持，从而让单独编译的模块也可以支持多态（对任意的类型进行操作）。而模块内部的可见性也是完全可控的。Functor 可以让模块特化为特定的实例，就像没有恼人的 C++ 模板一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;所以主要的问题是数据结构。ML 非常适合定义复杂数据结构和围绕它们的递归算法。ML 对最基本的数据结构（如列表、数组、结构、联合体、哈希表、二叉树、队列等）提供了良好支持。可以以此为基础方便地构造出另一门全新的语言。&lt;/p&gt;
&lt;p&gt;ML 是一种完美的语言吗？答案是否定的。和其它的语言一样，它也有很多缺陷：ML 的语法有些晦涩、类似&lt;code class=&quot;language-text&quot;&gt;printf&lt;/code&gt;这样的简单功能写出来很奇怪……在很多领域 ML 都不能适用（比如我投入很多精力的嵌入式系统开发），例如，在 DSP 芯片上用 ML 来写 FFT 算法将是一场噩梦；据我所知，ML 也不适用于 GUI 开发；ML 也缺少对面向对象的支持（尽管我觉得这是 ML 的特性而非缺陷）。但所有语言都有它们适合发光发热的领域，而我认为编译器开发就是 ML 的适用领域之一。这种感觉就像你在编写编译器的其中一个函数时突然需要一个 9mm 的螺丝扳手，打开 ML 的工具箱，在箱子的抽屉里就有一个顺手的扳手；又过了几分钟，又需要一个磁吸十字螺丝刀时，工具箱里恰好也有一把顺手的螺丝刀。这不是说 ML 的工具箱里有大量工具（事实上，ML 的工具箱比其它的工具箱小得多），因为工具箱由一群能工巧匠经过深思熟虑打造而成的，他们汲取了数十年的经验，对所有好的工具进行了专门设计，目的是打造快速、安全、健壮的程序对复杂数据结构进行递归操作。&lt;/p&gt;
&lt;p&gt;这些程序，就是编译器。&lt;/p&gt;
&lt;p&gt;Dwight&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译者注：&lt;/strong&gt;
[1]: read.pudn.com/downloads547/ebook/2256772/CInterfacesandImplementation/C%20Interfaces%20and%20Implementations.pdf&lt;/p&gt;
&lt;p&gt;[2]: In computer science, a tagged union, also called a variant, variant record, choice type, discriminated union, disjoint union, sum type or coproduct, is a data structure used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a tag field explicitly indicates which one is in use. It can be thought of as a type that has several “cases”, each of which should be handled correctly when that type is manipulated. This is critical in defining recursive datatypes, in which some component of a value may have the same type as the value itself, for example in defining a type for representing trees, where it is necessary to distinguish multi-node subtrees and leafs. Like ordinary unions, tagged unions can save storage by overlapping storage areas for each type, since only one is in use at a time.&lt;/p&gt;
&lt;p&gt;[3]: Automated theorem proving (also known as ATP or automated deduction) is a subfield of automated reasoning and mathematical logic dealing with proving mathematical theorems by computer programs. Automated reasoning over mathematical proof was a major impetus for the development of computer science.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[About · 关于我]]></title><description><![CDATA[My name is Tsang Ka-lung(in Cantonese).I am still a ECE student in Beijing University of Posts and Telecommunications.This diary is designed…]]></description><link>https://tsangkalung.github.io/about-me/</link><guid isPermaLink="false">https://tsangkalung.github.io/about-me/</guid><pubDate>Sat, 27 Jul 2019 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;My name is Tsang Ka-lung(in Cantonese).I am still a ECE student in Beijing University of Posts and Telecommunications.This diary is designed to help me record what I learned every day.&lt;/p&gt;
&lt;p&gt;我叫曾家龙，就读于北京邮电大学，主修 ECE。&lt;/p&gt;
&lt;p&gt;本博客用于存档我写的一些技术文章及翻译的译文，它还是我的技术日记，用于记录我每日的技术收获。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Learn more about me, please by the following ways.&lt;/p&gt;
&lt;p&gt;你也可以在以下网站找到我。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/TsangKalung&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.instagram.com/kalung_tsang&quot;&gt;&lt;strong&gt;Instagram&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.douban.com/people/Kalung_Tsang&quot;&gt;&lt;strong&gt;豆瓣&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[北京的夜雨]]></title><description><![CDATA[…]]></description><link>https://tsangkalung.github.io/beijing-rain/</link><guid isPermaLink="false">https://tsangkalung.github.io/beijing-rain/</guid><pubDate>Sat, 27 Jul 2019 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;刚刚在豆列里看到她写的日记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;北京至广州的高铁的沿线风景，应数湖南境内最佳。湖南的景色，是独集山丘，秀木，丛林，田野，水塘，炊烟人家于一身，且有着赏心悦目的搭配，构成上佳组合，夕阳播下，更是笼罩了一层金色的光晕。这景怎么赏得完！可惜树林与隧道颇多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这在铁道友中已是广泛的共识，我也曾和很多人提起过。但是这是一个法语专业的女生，如果她也这样认为，那么我会相信这是一种普罗的看法或体验。在冬天回家时，乘坐 G79 次列车会是一种很奇妙的体验：北京的温度是-10 摄氏度，terminal 的温度是 25 摄氏度。这样的温差意味着你会在两千余公里的旅途中历经四季的变换。&lt;/p&gt;
&lt;p&gt;说些题外话，我觉得北京最美的季节是秋季:绚烂的季节将街道染成金黄色，落下的银杏叶渐厚地堆叠着，人们踏着落叶享受着清爽的秋风。这种冲击感在我看来，对于初次见到的人是一种高于感官阈值的体验——在从小长大的地方，秋也许只意味着一丝十几天长的微妙的凉意，但突然尝饱、赏尽这溢出眼眶的秋色，却让人有些不适应。陶然亭的芦花、钓鱼台的夜柳、颐和的明月，当然还有学院路的同学在欣赏铺满银杏的校道，这一切无不让人感到心旷神怡。银杏叶的弧度和缺口是天造的美学，透过斑驳的叶影，你能看到群青色的天空——蓝到不真实、蓝到有些发紫，这也是在岭南看不到的，岭南的蓝天是克制的水蓝色。&lt;/p&gt;
&lt;p&gt;但倘若到了冬季，一切美仿佛都褪去了。华北平原是这样的严酷萧瑟，以至于你看不到黑与白之外的颜色，人们的羽绒服只有黑白灰色，树林只剩下树杈，天空只飘过锅炉的雾气。有时候觉得在小路旁种着杨树真是很愚蠢的事情，杨树真是我见过最可恶的植物：春天飘出杨絮，夏天最盛时也没有几片叶子，甚至，它的绿色也是一种加了灰度的绿色，到了冬天时只剩下徒增忧愁的小树丫，两排伫立在行道旁。这样的萧瑟会持续非常漫长的一段时间，人也变得非常的忧郁，有时候甚至会对着图书馆窗外的「灰」森林留下眼泪。这样的冬天不仅凌冽在颜色的匮乏上，更摄人心魂的是从遥远的西伯利亚吹来的朔风，但说实话，这是伤感的冬天中唯一让我感到喜欢的事物——冷风让人无比清醒，让人感到「実感」，让人无比精神，让人觉得灵魂在自己的完全掌控下。&lt;/p&gt;
&lt;p&gt;忧伤冬天的结束的契机，就是跳上 G79 次列车之时。你会觉得终于和这个凌冽的冬天告别了，回到时常想念的天气预报里永远气温二三十度的南海之滨。于是奇妙之旅开始了，一切发生在短短的八小时里；第一个小时，窗外依然是严酷的塞外之景，一片灰霾笼罩的萧索，华北平原如同唐人所咏的军旅塞外诗；经过郑州之后，景色慢慢开始不同：漂泊着浮冰的黄河上还有人在撑船，黄河在冬天并不是黄色，而是一种黑褐色；第四个小时，在武汉，终于看到了冬天的第一场雪，雪花附在松树上不愿化去，长江显得有些汹涌，街道上熙熙攘攘；当穿过湘南粤北的重重隧道后，芭蕉叶开始显现，第一次来到岭南的乘客开始惊叹这种与人同高的大叶子，木瓜树和芋叶也密布在河网中；对我而言：经过朔方的雄奇、黄淮的克制、荆楚的初雪之后，终于回到了毓秀的岭南；经过苦寒后，终于回到了没有季节的地方。在古代，京城出发的千里驿马跑到这里已疲倦不堪，而远航到南洋的海船正时刻准备拔错出发。&lt;/p&gt;
&lt;p&gt;当然，岭南的翠绿和北国之秋的金黄一样，也是远远超过人的感官阈值的：时隔半年再次看到孩子们在郁郁葱葱的草地上嬉戏打闹、老人们在数百年已成林的榕树下吟唱《荔枝颂》、青翠从脚底的青苔一直延伸到远山的大王椰。我心中对岭南的剪影是这样的：在马赛克装饰的骑楼中，摆放着古色古香的明清木家具和功夫茶具，窗外是有些让人感到惊奇的棕榈和榕树。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 560px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f0b774a549aa99358bc99edc554fae90/9342c/jingguang.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 297.9729729729729%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAA8ABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMCAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB96NYlwYzWBdwZxrq7CI1HQf/xAAdEAABBAMBAQAAAAAAAAAAAAACAAEDMhARIRIg/9oACAEBAAEFAkLu5LW1FRHWOmIuMi4INxSUDXnEfz//xAAUEQEAAAAAAAAAAAAAAAAAAAAw/9oACAEDAQE/AQ//xAAUEQEAAAAAAAAAAAAAAAAAAAAw/9oACAECAQE/AQ//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAQIFECMXH/2gAIAQEABj8CnLWPagsjRokRtuioFZ9x/8QAHhAAAgICAwEBAAAAAAAAAAAAAREAIRAxQVFhcYH/2gAIAQEAAT8hhkZWgD3zFCGwcOvk/Yzr6RawgtPBaggCjU/MGQAUHcXtt8NYtHiWeqwaFQUD1eusEwAbjn//2gAMAwEAAgADAAAAEOfMTJDCfP/EABkRAQACAwAAAAAAAAAAAAAAABARQQEhMf/aAAgBAwEBPxDHCiidQf/EABQRAQAAAAAAAAAAAAAAAAAAADD/2gAIAQIBAT8QD//EACAQAQEAAgICAgMAAAAAAAAAAAERACExUUFhcYGhsfH/2gAIAQEAAT8QQ4/GGGgSND+D6cKKt+HNWQG77xk6Sg0mq5PTI7ZHhfGaK+UVahgKeMCQMZpnGcNgSG4E/c+snq5XAZdoes3NCGACzwHE4y3vCxURHKqMMpYsJuwmM8szYRYcYSFTy9bdce/vF6LinWE0AXblZ//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;roadmap&quot;
        title=&quot;roadmap&quot;
        src=&quot;/static/f0b774a549aa99358bc99edc554fae90/9342c/jingguang.jpg&quot;
        srcset=&quot;/static/f0b774a549aa99358bc99edc554fae90/a80bd/jingguang.jpg 148w,
/static/f0b774a549aa99358bc99edc554fae90/1c91a/jingguang.jpg 295w,
/static/f0b774a549aa99358bc99edc554fae90/9342c/jingguang.jpg 560w&quot;
        sizes=&quot;(max-width: 560px) 100vw, 560px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，这两千余公里旅途中最美的一段如开头所说，是京广高铁湖南的一段——严格来说：长沙以南，韶关以北。我其实不太认同江韵说「隧道颇多」是一个遗憾，反而觉得这一段路程多隧道是锦上添花。在高速奔驰的列车中，你觉得路途遥远却耳熟能详的一个又一个都市被一个小时一个小时地快速掠过，本已是一种乘坐飞机无法体验到的感觉；但在穿过第一个隧道之后，你会发出「哇」的一声惊叹。在瑰丽的群山的环抱中，是一片广袤的盛开着的油菜田，我看到一群孩子在其中追逐——然后，高速的列车冲入下一个隧道，我在心中莫名觉得隧道变成了一幕幕表演中间的幕布，果不其然——通过隧道后是像桃花源一样的小村，土地平旷，阡陌交通，规整娟秀的村舍坐落在青绿的农田的包围中，飘出袅袅炊烟，这是多少人渴望的归田园居。穿过下一个隧道，则发现列车在数十米高的桥梁上，而一边的山势陡峭，翡翠色（没有夸张）的溪流汇入谷底，变成一条小溪。远处可以看到一座断桥，那是詹天佑修筑的粤汉铁路的遗址——此处为湖南和广东的省界。穿过无数个隧道之后，迎接你的是无尽的绿意和暖湿粘腻的空气——是这样的不同——在几个小时前你吸入胸腔的还是西伯利亚吹来的清冷干冽的冬风。中国有许多景色出众的铁路，但这一段绝对是其中最特别的：经历最长的路程、四个季节的变换，穿越于两个世界之间，以及属于潇湘的特别。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回忆起这些，窗外是北京的夜雨。&lt;/p&gt;</content:encoded></item></channel></rss>