<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Tsang's Blog]]></title><description><![CDATA[Tsang's Blog]]></description><link>https://tsangkalung.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 07 Dec 2020 21:30:25 GMT</lastBuildDate><item><title><![CDATA[译文：Static TypeScript，TypeScript 的一种静态编译器实现]]></title><description><![CDATA[译者声明：本译文获得原作者授权翻译；由 Allen 审校。 作者： Thomas Ball，微软研究院，Redmond，tball@microsoft.com Peli de Halleux，微软研究院，Redmond，jhalleux@microsoft.com Michał…]]></description><link>https://tsangkalung.github.io/static-ts/</link><guid isPermaLink="false">https://tsangkalung.github.io/static-ts/</guid><pubDate>Mon, 23 Nov 2020 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;译者声明：本译文获得原作者授权翻译；由 Allen 审校。&lt;/p&gt;
&lt;p&gt;作者：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Thomas Ball&lt;/strong&gt;，微软研究院，Redmond，tball@microsoft.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peli de Halleux&lt;/strong&gt;，微软研究院，Redmond，jhalleux@microsoft.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Michał Moskal&lt;/strong&gt;，微软研究院，Redmond，mimoskal@microsoft.com&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;综述&lt;/h2&gt;
&lt;p&gt;基于单片机的嵌入式设备通常使用 C 语言进行编程。这类设备如今进入了计算机科学教学的课堂，甚至一些中学也开办了相关的课程。于是，用于单片机编程的脚本语言（如 JavaScript 和 Python）使用也逐渐增加。&lt;/p&gt;
&lt;p&gt;我们研发了 Static TypeScript（STS），它是 TypeScript 的一种子集（而 TypeScript 本身是 JavaScript 的超集），还研发了相关的编译/链接工具链，它们全部使用 TypeScript 进行开发并且在浏览器中运行。STS 为实践开发而设计（特别是实践教学），适合针对小型设备的静态编译。用户开发的 STS 程序将在浏览器中被编译成机器码，并链接预编译的 C++ 运行时，生成比普通的嵌入式解释器更高效的可执行文件，从而延长电池寿命并可以在 RAM 低达 16kB 的设备（例如 BBC micro:bit）上运行。本论文主要对实现 STS 系统和开发适用于课堂教学的嵌入式编程平台的技术挑战进行综述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;JavaScript，TypeScript，编译器，解释器，单片机，虚拟机&lt;/p&gt;
&lt;h2&gt;1 简介&lt;/h2&gt;
&lt;p&gt;近年来，课堂上计算机的实物教学不断地发展，以鼓励孩子们构建自己的简单的交互嵌入式系统。例如，图 1（a）展示了 BBC micro:bit[1]，它是一种受 Arduino 启发的小型可编程单片机，带有集成的 5X5 LED 显示点阵、几个传感器和低功耗蓝牙（BLE）无线传输。该设备与 2015 年首次向英国所有 7 年级学生推出（10 至 11 岁），随后走向全球，迄今为止 micro:bit 教育基金会（ &lt;a href=&quot;https://microbit.org&quot;&gt;https://microbit.org&lt;/a&gt; ）已经发放了四百万个设备。图 1（b）则展示了另一个以 RGB LED 为特点的教育设备 Adafruit’s Circuit Playground Express (CPX)。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a99b064967e9368263d4f1bb52ca18e4/6c68b/figure_1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACl0lEQVQoz42T30uTURjH9590E12YqdgPIeb8semmU+fUaalzS53OX8nMJHelqERu60YDLZWEAgMLIrop6CI0KPBCSCIMSafl3HRb5tja3vfT66YTu+rAOZzzvN/n85xz3u+RIYr8TxMlnSAIybnf7yO460WIRhIxQYzHZTFpOPjpJ7zmJez249nysLrlZnvHh8e3h3c3QCgckcQJWGDXx6vn09x39jHvGOHF6CAb66vJQrLIQYRvheM4r3TSW9CJSdNEW5EFVXEteaVGspSVjE09iSf83vfjHLnNgNVArTqb3Avp9Gmq6Kkz8n11Ja6RRQIhbHIL57LUpOWVUVRQj7XQilxpIDO3nLNpedgHXXHx29fzWLs0mOpUKDIvcTklBUNuKd3ydiaG7yISQ+bdC6A3WVGV1pOVX4ne2EbBtUaKq5u5qqlBV9yAwzUZB05MOqiyVdBjs1BZqqVMXUSdwUB7pZ3+jiF8O25kHumOWpq70FcYycwpR2toQlNxg0K9iRzp2CW6Glzjj+LAmSkXyg49umo9WqWKfEU+NdoS6s3j9NucBPd+SEBphypFFecvakiTl6CWYPllRgr05niBM6kKuu8Mx4GfFt6hszWRWl1LlaEBvbac9LybZJU5mHgwk7hDn/TX7g1102KpZXigF3OjiZEhO5bWZgYH7XR2mnk2N0VMOLRGjKczY1Tf6iejyExGWjbKplHsUsHg7nYCGA4f4F6e5eviGOvL83z58JjNzy9ZWZxlbWmOlfcuNlffcOJWkaWPC7S0dmG83sz0xEPEaOjENoe+jkZF/kRjRKVtBH/ts7HhlubSOprogiAmE47BAb+fzU33KeMfAU+/lFAohMfj+fedJBOO9cFgEK/XdxQTkt/+AjhFnH73LZBpAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;图1&quot;
        title=&quot;图1&quot;
        src=&quot;/static/a99b064967e9368263d4f1bb52ca18e4/fcda8/figure_1.png&quot;
        srcset=&quot;/static/a99b064967e9368263d4f1bb52ca18e4/12f09/figure_1.png 148w,
/static/a99b064967e9368263d4f1bb52ca18e4/e4a3f/figure_1.png 295w,
/static/a99b064967e9368263d4f1bb52ca18e4/fcda8/figure_1.png 590w,
/static/a99b064967e9368263d4f1bb52ca18e4/efc66/figure_1.png 885w,
/static/a99b064967e9368263d4f1bb52ca18e4/c83ae/figure_1.png 1180w,
/static/a99b064967e9368263d4f1bb52ca18e4/6c68b/figure_1.png 1888w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 1&lt;/strong&gt; 两个 Cortex-M0 的单片机教育设备：(a) BBC micro:bit 拥有包含 16kB RAM 和 256kB 闪存的 Nordic nRF51822 微控制单元；(b) Adafruit’s Circuit Playground Express ( &lt;a href=&quot;https://adafruit.com/products/3333&quot;&gt;https://adafruit.com/products/3333&lt;/a&gt; ) 拥有包含 32kb RAM 和 256kB 闪存的 Atmel SAMD21 微控制单元。&lt;/p&gt;
&lt;p&gt;研究表明在计算机科学教育中使用这样的设备会增加对孩子们的吸引力，尤其是对于女生，还可以增加孩子们和老师们的自信，让课堂教学更加生动[2,16]。&lt;/p&gt;
&lt;p&gt;为了控制课堂教学的成本，这些设备一般使用 16 到 256kB 的 32 bit ARM Cortex-M 单片机，使用额外的计算机（通常是笔记本电脑或台式机）进行编程。在课堂上用这类设备进行编程教学有一系列技术挑战：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;选择/设置合适该年龄段学生的编程语言和开发环境&lt;/li&gt;
&lt;li&gt;教室的计算机使用的操作系统通常是过时的，互联网连接也不稳定或速度慢，并且可能被学校的 IT 管理员限制访问外部网络，这使得安装原生应用程序有种种困难&lt;/li&gt;
&lt;li&gt;学生开发的程序要从计算机转移到电池供电的嵌入式设备上（正如很多项目都在实验中提供这种设备，若没有提供也可以“改造”。）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;面对这些挑战，有许多流行脚本语言的嵌入式解释器应运而生，例如 JavaScript 的 JerryScript[8,15]、Duktape[22]、Espruino[23]、mJS[20]、MuJS[19]，Python 的 MicroPython[9]及其分支 CircuitPython[12]。这些解释器直接在微控制器上运行，仅依赖从计算机向嵌入式设备传输程序文本；但它们也舍弃了深度优化的 JIT 编译器（如 V8）的一些优势，这类编译器运行需要的内存比单片机的内存要大两个数量级。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/38ae4fc4f46d4915ad282e58fad72977/79e48/figure_2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 93.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAACxKAAAsSgF3enRNAAAFbklEQVQ4yx2Ue1TUZR7Gf53jZqh5qVbDsmPZdtraij171lUokS66GbXkitrRkIuIXJ0kAkZY1IkUS7eCo2QW5CCoUTYslxkEB5gZhrkw9xs4DJeRS227bbdzfrtn+3362R/PX+/5Pu/zfJ/nfYW5iaD41dQoX06OSrOREN9/FeVUzZsM9V/lX9Ew0es+oqMeoiEn0RE3NwIW3H1tjPjcTIeDTI9dJ2zR4jP3MCWfC7ORoDg3PsJMJChNh/38ezpCdkYa6o/O8M1MhEjAwbh/mEmfnRl5IPxJHvrcX+M+l8/oZyomWpV4Dj3AxYoUQh4HwvSYX5wZC3Aj7JOi1/1Egm4SNzzFkYpyvo7Kt3vtRLxWooFhorZeJqtWcSXnIWoKUjhUuJsjRTvpVayh++AjWExGhKmwR5yO+JgIuaSpUS8TssXEpESqDpUxNx4gYDcStA8w5bMyOdTJZPldrFfUI5yAeW/+iFAJpQXp9JU+wbDNhjDqt4uq6mMUKV6Tdqbls3dXHsUFlZy/0E1dvYZCRQlbXtpGw+k6Zh09jJYsJ06hRjj8E/OVXyPkT3E04zn0FQl4nLLlgNMqJiW/Qty6Z6Q/pe4nTt3BY+0OHr8WJq6qnoT4RO58KIHKciVzzl7cpat5ectLPLyxkN8/lcZjCXs4mxpLj+pFgl45lJDbJuYUFPD8s09LzynfYvF/4JbxHxDmYNH7l3nyd/cTtz6RvymVTNt1RCpWc25rDLr0GLwF89FmLsKQNY++OgVjIR9CUFaYmlnIq5n50vGGVhRzP5Ax+y27v/2JpDPN/PG397P0N0+SW1jGN65OGtPXUPvXuzi1dQXNGcs5vjUWdeoChpqqCQe9CH7HoFhR/XdU79RL753+kLLaD8ip+ZjtRy+xKa2C+MQ/c88Tm8grKmXW8gU2RSzv/mUJmvSltMlo3nUHM8XzMLS8SyTkl0PxWkSTsY/aDxqlvfnFbE7ew8bkA6zdXMHaTQoeTUjh8fgtqA5XEbZ2oy5cT2XyPZzYsYbqlHs5+uJKzmb/AY+hgzG/6+YOzWLANYS5v0fStV9Bf1VLt7YDXaeGrvY22to6foHJMIDTbqNNo6HlwidoPm2irfUin11Uo5XnwnLxw3JfBZ/TLHodgwTdZsk7bEB74Rj95wrQncnjam0a195L5erJFDqOJ/OPYy+gO7WdrpptqGv2c/z1VDSXPmRyxEXIOch1r9xDr+MmoQmfyyoN6ZrQl9+H/8gy7GUxdJWspi5vPW/nJlCTl4gqax3NefdhPHAbtfse5fQrAvWqbPldOwm5ZEKPTOi2m0SPrMzrsEienvNEqu/m9ZQ1fJH1Kw4rMxGKv0PIuYFw8P8I266Rm7QMk/J2mXgJDTtupeFYDiG/TOg0MeqRLTttRtFtNeCxD0l+vZryrQ+SvekB9m1YSmbuHuarYPHBf7KwCubvdZK94XbO71uBemcsdWsXUleZwYjfgc9hYMRlQXBYBkSXpR+3zSwNdzfSeeBOdietkrs2jxOlKSwqH2dpcYDFygkW7FCza+MdfL4nljObl6MpuJVzR9IIyr/Mzf2HnGYEu7lPHDbrcVpNklXbKAUrYqSW7CWStmih1FQcJ5W8miRVZcRLqqx4qSw9QSrPWic17l8sNeQvkz7ff4tUX7ldCrgdksc+IPkdZkmwGq/9zz7Yh9NixND9KWf3raQ1fQGXM2JQH3iEkxkPoyuKoVOxiPY3VnE491mqd93NleKV1GatoP5kyS8K3fabOcgKrYae72TS/9pMetFi7BF72xpFo+asONj+sWjqahYHui6JZm2TjBZxSNci2npaRbf+sujUt4qW3iuiY6hfdFnlHGwGOVyj+DPlRhEVq1zl1wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;2&quot;
        src=&quot;/static/38ae4fc4f46d4915ad282e58fad72977/fcda8/figure_2.png&quot;
        srcset=&quot;/static/38ae4fc4f46d4915ad282e58fad72977/12f09/figure_2.png 148w,
/static/38ae4fc4f46d4915ad282e58fad72977/e4a3f/figure_2.png 295w,
/static/38ae4fc4f46d4915ad282e58fad72977/fcda8/figure_2.png 590w,
/static/38ae4fc4f46d4915ad282e58fad72977/79e48/figure_2.png 865w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 2&lt;/strong&gt; 三款有 160x120 分辨率彩色屏幕的基于单片机的游戏机，这些开发板使用 ARM 的 Cortex-M4F 核心：ATSAMD51G19（192kB RAM，以 120Mhz 主频运行）和 STM32F401RE（96kB RAM，以 84Mhz 主频运行）。&lt;/p&gt;
&lt;p&gt;很不幸的是，这些嵌入式解释器都比 V8 慢几个数量级（详细对比见第 4 节），影响响应速度和电池寿命。更重要的是，由于内存中的对象表示为动态键值映射（dynamic key-value mappings），因此它们的内存占用量可能是实现同样功能的 C 程序的几倍，这一点严重限制了程序在更低内存的机器上(如 16kB RAM 的 micro:bit 和 32kB RAM 的 CPX)运行的可能性。&lt;/p&gt;
&lt;h3&gt;1.1 Static TypeScript&lt;/h3&gt;
&lt;p&gt;作为上述嵌入式解释器的替代，我们开发了 Static TypeScript（STS），它是 TypeScript 的语法子集[3]，由一个用 TypeScript 编写的编译器支持，该编译器可以生成在 16-256kB RAM 的微控制器上高效运行的机器码。STS 及其编译器和运行时的设计主要着力于解决前文提到的三个挑战。确切来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STS 削除了 JavaScript 大部分的「糟粕」；受 StrongScript 影响[14],对于静态声明的类，STS 使用名义类型（nominal type），并支持用虚拟函数表的经典技术对类进行高效编译。&lt;/li&gt;
&lt;li&gt;STS 工具链是离线运行的，一旦加载入浏览器，就不再需要 C/C++ 编译器。它们用 TypeScript 实现，将 STS 编译为 ARM Thumb 机器码并在浏览器中将其与预编译好的 C++ 运行时链接————浏览器或许在大多数时候是课堂中唯一可用的运行环境了。&lt;/li&gt;
&lt;li&gt;令人惊喜的是，STS 编译器生成的机器码高效而紧凑，使得我们解锁了一系列应用领域，例如图 2 中所示的低配置设备的游戏编程，它们能够运行全都得益于 STS 提供的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将 STS 用户程序部署到嵌入式设备不需要安装特别的应用或设备驱动，只需要进入浏览器即可。完成编译的程序以文件下载的形式显示，然后用户将文件传输到显示为 USB 存储器的设备中即可（或者直接通过 WebUSB 协议传输，它是一种即将推出的将网站与物理设备连接的协议）。&lt;/p&gt;
&lt;p&gt;STS 简单编译的编译方案（将在第 3 节详述）在一系列小型 JavaScript 基准测试中取得了惊人的优秀表现，性能可以和 V8 等先进前沿的 JIT 编译器媲美，而所需的内存则比他们低几个数量级（详情见第 4 节）；同时，也比嵌入式解释器快至少一个数量级。评估的一个特别之处是对处理类、接口和动态映射（dynamic maps）的字段/方法查找的不同策略的比较。&lt;/p&gt;
&lt;h3&gt;1.2 MakeCode：为教学而生的简单嵌入式开发&lt;/h3&gt;
&lt;p&gt;STS 是 MakeCode 框架支持的核心语言（详情见 &lt;a href=&quot;https://makecode.com&quot;&gt;https://makecode.com&lt;/a&gt; ；该框架及诸多编辑器已按 MIT 协议开源，请见 &lt;a href=&quot;https://github.com/microsoft/pxt&quot;&gt;https://github.com/microsoft/pxt&lt;/a&gt; ）。MakeCode 支持为单片机设备创造自定义的嵌入式编程实验。每个 MakeCode 实验（我们一般称其为编辑器（editors），虽然它们也包含了模拟器、API、教程、文档等）通过 STS 针对特定设备或设备类型进行编程。&lt;/p&gt;
&lt;p&gt;大多数 MakeCode 编辑器主要以 Web 应用的形式部署，其中包含了用以开发 STS 程序的功能齐全的文本编辑器，它基于 Monaco（VS Code 使用的编辑器组件）；还包含了基于 Google Blockly 框架的图形化编程界面（注释中的 STS 元数据定义了 STS 的 API 到 Blockly 的映射，MakeCode 会在 Blockly 和 STS 之间进行交互）。&lt;/p&gt;
&lt;p&gt;MakeCode 编辑器和原先 BBC micro:bit 和 Adafruit CPX（详情见 &lt;a href=&quot;https://makecode.microbit.org/&quot;&gt;https://makecode.microbit.org/&lt;/a&gt; 和 &lt;a href=&quot;https://makecode.adafruit.com/&quot;&gt;https://makecode.adafruit.com/&lt;/a&gt; ）的编程实验至今已经覆盖了全球的数百万学生和教师。&lt;/p&gt;
&lt;p&gt;STS 支持包（package）的概念，即 STS、C++、汇编代码文件的集合，并支持把其他的包当做依赖。第三方开发者已经利用这样的能力对 MakeCode 编辑器进行扩展，使之可以支持各种开发板的外接设备（micro:bit 的相关示例见 &lt;a href=&quot;https://makecode.microbit.org/extensions&quot;&gt;https://makecode.microbit.org/extensions&lt;/a&gt; ）。值得注意的是，大多数包完全用 STS 编写从而避免了不安全 C/C++ 的陷阱，这主要得益于高效的 STS 编译器以及通过数/模针脚（GPIO、PWM、servos）和一些协议（I2C 和 SPI）访问硬件实现的底层 STS API。&lt;/p&gt;
&lt;p&gt;图 3 展示了用来为图 2 中的手持游戏设备进行编程的 MakeCode Arcade 编辑器（事实上，图中编辑器里的 STS 程序就是在三个单片机设备中运行的游戏之一，它是一个简单的平台游戏）。MakeCode Arcade 包含了一个大部分由 STS 编写的游戏引擎，因此对代码运行效率提出了很高的要求，因为要在高帧率下实现令人快活的视觉效果。该游戏引擎包含游戏循环逻辑、事件上下文栈、物理引擎、文字线条绘制等模块以及用于特定游戏的框架（比如，为图中的平台游戏（译者注：platformer games，这是一种游戏类型）），游戏引擎一共由一万行 STS 代码和少数最基础的 C++ 图像模糊函数组成。该游戏用 Arcade 构建，在浏览器（桌面或移动端）运行，或在不同型号但符合配置要求的单片机上运行（160*120 像素 16 色屏幕和 100MHz 左右主频、100kB RAM 左右的微控制器）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 3&lt;/strong&gt; MakeCode Arcade 编辑器。左边的面板是 Arcade 设备的模拟器；中间的面板是编辑器中可用的 API 的目录；右边的面板是 Monaco 编辑器，可用在其中用 STS 代码为平台游戏编程（ &lt;a href=&quot;https://makecode.com/85409-23773-98992-33605&quot;&gt;https://makecode.com/85409-23773-98992-33605&lt;/a&gt; ）。位于顶部的开关用来在模块可视化编程和 Static TypeScript 编程面板之间切换（由于市场因素，被标记为 JavaScript）。&lt;/p&gt;
&lt;p&gt;本文的主要目的是详述了该广泛应用的系统和解决上述课堂教学难题的方法。&lt;/p&gt;
&lt;h2&gt;2 Static TypeScript(STS)&lt;/h2&gt;
&lt;p&gt;TypeScript[3]是 JavaScript 的渐进式[18]超集。这意味着所有 JavaScript 程序都是 TypeScript 程序并且其类型是可选的、按需添加的，这些类型能让 IDE 提供更好的支持，也能让大型 JavaScript 程序有更好的错误检测（error checking）。对象类型提供了映射（maps）、函数和类的统一形式。对象类型之间的结构子类型（structural subtyping）定义了可替换性（substitutability）和兼容性检查。经过类型擦除（及较小的语法转换）后生成原始的 JavaScript 程序。&lt;/p&gt;
&lt;p&gt;STS 是 TypeScript 的子集，TypeScript 继承了 JavaScript 的一些高度动态化的语法：&lt;code class=&quot;language-text&quot;&gt;with&lt;/code&gt;语句、&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;表达式、基于原型（prototype）的继承、类之外的&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;指针、&lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;关键字、&lt;code class=&quot;language-text&quot;&gt;apply&lt;/code&gt;方法。STS 保留了诸如动态映射（dynamic maps）的特性，但将它们与名义类抽象分开。这样的限制是可以接受的，因为大多数初学者编写的程序都非常简单，而且嵌入式领域的 JavaScript 库或 TypeScript 库非常少，所以使用这些被限制的 JavaScript 特性（如猴子补丁，monkey patching）的机会很少。&lt;/p&gt;
&lt;p&gt;我们的目标并不是让 STS 支持 TypeScript 的全部功能，而是务实地针对用户需求，按嵌入式编程所需添加语言特性。&lt;/p&gt;
&lt;p&gt;与所有对象类型都是属性包的 TypeScript 相比，STS 在运行时拥有四种不相关的对象类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;动态映射&lt;/em&gt;类型，它具有命名属性（即字符串索引），能保存任何类型的值&lt;/li&gt;
&lt;li&gt;&lt;em&gt;函数&lt;/em&gt;（闭包）类型&lt;/li&gt;
&lt;li&gt;&lt;em&gt;类&lt;/em&gt;，用以描述类的示例，通过访问每个字段/方法进行高效的运行时子类型检查，对它们进行名义上的处理，后文中会详述&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数组&lt;/em&gt;（集合）类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;某种程度上，STS 与 Java 或 C# 的风味更接近，它们都把类型视作「抽象的守护神」（protectors of abstractions），而不像 JavaScript 那样允许更自由地处理对象。在 3.4 节的讨论中，运行时类型标签（type tags）用于区分上面列出的不同种类的内置对象类型（以及诸如装箱数字（boxed number）和字符串之类的语言基础构件）。&lt;/p&gt;
&lt;p&gt;与 TypeScript 中一样，类型转换不会生成任何代码且不会失败。相反，STS 在字段/方法访问点保护名义上的类抽象。当&lt;code class=&quot;language-text&quot;&gt;x == null&lt;/code&gt;时，&lt;code class=&quot;language-text&quot;&gt;x.f&lt;/code&gt;在 JavaScript 中会导致运行时错误。如果&lt;code class=&quot;language-text&quot;&gt;T&lt;/code&gt;是具有字段&lt;code class=&quot;language-text&quot;&gt;f&lt;/code&gt;的类，并且&lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;的动态类型不是&lt;code class=&quot;language-text&quot;&gt;T&lt;/code&gt;的名义子类型，则&lt;code class=&quot;language-text&quot;&gt;(x as T).f&lt;/code&gt;在 STS 中将导致运行时错误。如果&lt;code class=&quot;language-text&quot;&gt;T&lt;/code&gt;是接口、&lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;或某种复杂类型（例如，union 或 intersection），则与&lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;的动态类型无关，而是根据名称查找该字段。&lt;/p&gt;
&lt;p&gt;其他抽象在运行时中也受到保护，正如在 JavaScript 中那样：例如，对非&lt;em&gt;函数&lt;/em&gt;类型的对象进行函数调用。现在，将属性动态添加到除&lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt;类型之外的任何其他类型是错误的。我们将来可能会取消对动态 JavaScript 语义的限制，这取决于用户的反馈。迄今为止，在我们的用户社区（教育工作者和开发人员）中还没有收到任何关于这些限制的负面反馈。&lt;/p&gt;
&lt;p&gt;STS 基本类型根据 JavaScript 语义进行处理。特别要强调的是，所有的数字类型在理论上都是 IEEE 64 位浮点类型，但也有可能实际使用 31 位带符号标记的整数类型。运算符的实现（例如加法或比较）基于动态值的分支，以遵循 JavaScript 语义，并在汇编中手动实现了整数类型的快速实现。&lt;/p&gt;
&lt;p&gt;STS 既是 TypeScript 的语法子集又是语义子集，这意味着，如果程序在 STS 中成功编译，它将具有与等效 TypeScript 程序相同的语义，否则该程序会在运行时崩溃（在上述情况下）。&lt;/p&gt;
&lt;h3&gt;2.1 与 C++ 进行交互操作&lt;/h3&gt;
&lt;p&gt;STS 程序运行在单片机上由 C++、C、汇编实现的运行时里。该运行时实现了语言的基础构件（操作符、集合、类的支持、动态映射等），同样也支持对底层硬件的访问。该运行时能用包进行拓展，相关详情见 2.2 节。&lt;/p&gt;
&lt;p&gt;STS 支持调用 C++ 函数，反之，亦可以从 C++ 调用 STS 函数。为了简化这个过程，STS 使用了一直能够简单的代码生成策略，即在 C++ 函数中使用特殊的注释（&lt;code class=&quot;language-text&quot;&gt;//%&lt;/code&gt;）指定那些代码需要导出为 STS，这样的策略还用于导出为 Blockly 代码块（使用注释&lt;code class=&quot;language-text&quot;&gt;//% block&lt;/code&gt;）。构建中有一个步骤是解析 C++代码获取这些特殊的注释，还会收集这些函数的原型（签名），从而在调用它们时可以生成正确的转换。举个转换的例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// C++源码:&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; control &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;/** Register an event handler */&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//% block&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; eventType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Action handler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// arrange for pxt::runAction0(handler)&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// to be called when eventType is triggered&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 生成的TypeScript&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; control &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;/** Register an event handler */&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//% block shim=control::onEvent&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventType&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C++ 的命名空间和函数名直接映射到 STS 对等的代码上，原先的代码文档注释也会对应复制。注释&lt;code class=&quot;language-text&quot;&gt;//% block&lt;/code&gt;指定函数暴露为 Blockly 图形代码块，它也会被复制。还有许多其它可能的注释可以控制等效图形的外观。STS 函数还会有一个附加的&lt;code class=&quot;language-text&quot;&gt;shim&lt;/code&gt;注释，标注对应的 C++ 函数名（某些情况下，STS 声明是用用户编写的，这时候 C++ 函数名不必与 STS 函数名对应）。
C++ 的类型会映射到 STS 的类型，由于在 STS 中所有数字类型理论上都是双精度的（），所以 C ++ 的&lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt;类型会映射到 STS 的&lt;code class=&quot;language-text&quot;&gt;number&lt;/code&gt;类型。当 C++ 函数被调用时，STS 编译器会确保被传递的值被转换为整数。其它的 C++ 整数类型（例如&lt;code class=&quot;language-text&quot;&gt;uint16_t&lt;/code&gt;）也用相似的方法被支持。C++的&lt;code class=&quot;language-text&quot;&gt;Action&lt;/code&gt;类型代表对一个闭包的引用，它将和&lt;code class=&quot;language-text&quot;&gt;pxt::runAction0（）&lt;/code&gt;一起被调用。&lt;/p&gt;
&lt;p&gt;类方法还没有被直接支持，常规的函数能用于实现对象，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; BoxedBuffer &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;Buffer&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; BufferMethods &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//%&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getByte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Buffer self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; self&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;len &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; self&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//% shim=BufferMethods::getByte&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;getByte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有在&lt;code class=&quot;language-text&quot;&gt;BufferMethods&lt;/code&gt;命名空间中的函数都必须将&lt;code class=&quot;language-text&quot;&gt;Buffer&lt;/code&gt;作为第一个参数，并在 STS 这边作为&lt;code class=&quot;language-text&quot;&gt;Buffer&lt;/code&gt;类的成员。当这些成员被调用时，STS 编译器会确认第一个参数不是&lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;并且是&lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt;的子类型。这些接口在概念上可以理解为具有不透明表示形式的不可扩展类，即它们不能由常规类实现，并且成员解析是静态的（static）。选择接口语法是因为 TypeScript 允许用新方法在文件之间扩展接口。如果新方法具有上述的&lt;code class=&quot;language-text&quot;&gt;shim = ...&lt;/code&gt;注释，或者指定了使用 TypeScript 而不是 C ++替换函数的模拟注释，那么我们允许此类添加。这通常只在高级 C++ 包的开发中涉及（见下文）。&lt;/p&gt;
&lt;h3&gt;2.2 包（Packages）&lt;/h3&gt;
&lt;p&gt;STS 支持多种输入文件，也支持 TypeScript 的&lt;code class=&quot;language-text&quot;&gt;namespace&lt;/code&gt;语法用以区分作用域。文件不会引入作用域，并且当前不支持 JavaScript 模块。输入文件可以来自一个或多个&lt;em&gt;包&lt;/em&gt;。其中一个包为主包，可以列出其他包作为依赖关系，而后者又可以列出其他的依赖关系。有多种方法可以指定包的版本，包括内置包、用命令行进行操作时指定文件路径、GitHub 仓库的 URL。使用包时只能用一个版本（否则可能会发生重定义错误）。&lt;/p&gt;
&lt;p&gt;MakeCode 编辑器的构建者通常会决定打包一些随编辑器提供的内置包，这些扩展可以通过 GitHub 中的包进一步扩展。 MakeCode Web 应用程序支持将包发布到 GitHub。 因为命名空间独立于文件，所以包很容易扩展现有的命名空间。目前，STS 不对命名空间名称执行检查。&lt;/p&gt;
&lt;p&gt;MakeCode 附带了许多编辑器构建器可以附带的包（通用包），它们用以支持各种硬件功能（引脚、按钮、蜂鸣器、屏幕等），以及诸如处理 Sprite 的游戏库之类的高级概念。其中一些包是变体，共享界面但具有不同的实现方式（例如，用于不同屏幕的驱动程序）。&lt;/p&gt;
&lt;p&gt;外部（GitHub）包通常为其他硬件拓展设备提供支持。用户通常不会一次使用太多外部包，因此我们感到由于没有让命名空间强制不同名而导致名称冲突的风险很低，并且它允许将新的 API 自然地融入现有的名称空间。&lt;/p&gt;
&lt;h2&gt;3 编译器和运行时&lt;/h2&gt;
&lt;p&gt;STS 的编译器和工具链（链接器等）完全使用 TypeScript 编写。现在尚不支持单独编译 STS 文件，STS 是一个完整的程序编译器（支持缓存预编译的包，其中包含了 C++ 运行时）。STS 的设备运行时主要是由 C++ 编写的，包含定制的垃圾回收器。正如前文提到的，STS 并不计划支持 JavaScript 的全部功能。&lt;/p&gt;
&lt;h3&gt;3.1 编译工具链&lt;/h3&gt;
&lt;p&gt;TypeScript 源程序由常规 TypeScript 编译器处理，执行包括类型检查在内的语法和语义分析；这个过程产出带有类型注释的抽象语法树（AST），然后检查是否有 STS 范围之外的语言构件（类似&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;arguments&lt;/code&gt;等）。抽象语法树随后会转化为具有语言构件的自定义 IR 用以调用运行时函数。这种 IR 之后会被转换为下列的三种形式之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继续传递 JavaScript 运行到浏览器中（在单独的 iframe “模拟器”里）。&lt;/li&gt;
&lt;li&gt;与预编译的 C++ 运行时链接的 ARM Thumb 机器码，用以在裸机（A ‘bare-metal server’ is a computer server that is a ‘single-tenant physical server’. The term is used nowadays to distinguish it from modern forms of virtualisation and cloud hosting.）硬件和操作系统内部运行。&lt;/li&gt;
&lt;li&gt;自定义虚拟机的字节码，用于无法加载或生成动态语言的平台（例如 XBox 和 iOS）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ARM Thumb 机器码和自定义的字节码全都被生成为汇编代码，再由定制的汇编器转换为机器码。在本节中我们主要讨论原生 32-bit ARM Thumb 的转化过程（我们会在 4.2 节对比虚拟机的性能）。&lt;/p&gt;
&lt;p&gt;本段提到的常规的 TypeScript 编译器、STS 代码生成器、汇编器（assembler）、链接器（linker）均由 TypeScript 实现并且全部运行在浏览器或命令行中。&lt;/p&gt;
&lt;h3&gt;3.2 链接&lt;/h3&gt;
&lt;p&gt;生成的机器码将与一个预编译的 C++ 运行时链接。C++ 的编译在云上运行，编译生成的运行时缓存在 CDN 和浏览器中（可以选择使用所有 C++源码的强哈希算法进行缓存）。通常来说，用户编写他们的程序时，C++ 运行时不会更改，从而让离线操作成为可能[5]。&lt;/p&gt;
&lt;p&gt;生成的机器码通常会附加在预编译 C++ 运行时代码的后面，根据目标设备要求的文件格式（特别是 ELF）对生成文件进行一些修补。为了生成代码，汇编器需要运行时函数的地址，这些地址从运行时的二进制文件提取。&lt;/p&gt;
&lt;p&gt;包可能还要包含从运行时中继承出来的 C++ 代码。包含 C++ 的包组合都必须分别进行编译和缓存，这些也都是在云上运行的。到目前为止，这些可能是天量数字的包组合方式还没有出现大问题，因为学生一般不会一次使用很多外部的包，而且我们的经验是，为 MakeCode 编写的包很少使用原生 C++。&lt;/p&gt;
&lt;h3&gt;3.3 值的表示&lt;/h3&gt;
&lt;p&gt;编译后的程序使用常规的 C++ 栈储存局部变量、返回地址、临时的计算结果。存储在栈和对象内部的值通常使用统一的、与类型无关的表示形式，它的长度始终为 32 位。&lt;/p&gt;
&lt;p&gt;范围为$-2^{30}≤n≤2^{30}$的数字$n$由 32 位的值$2n+1$表示，所以最低位是确定的。其它的数字由常规对象特别是装箱的 64 位双精度数字类型表示。&lt;/p&gt;
&lt;p&gt;特殊的常量，例如&lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;由特定的 32 位值表示，最低位是确定的，最低位的下一位也是确定的（有$2^{30}$个这样的值的编码空间，但目前仅使用了几个位置）。JavaScript 的&lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;由&lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt;表示（对应 C++ 的&lt;code class=&quot;language-text&quot;&gt;NULL&lt;/code&gt;）,因为它是内存分配以及 JavaScript 字段和变量的默认值。&lt;/p&gt;
&lt;p&gt;所有其他值均表示为指向常量内存分配的对象或堆上分配的对象的指针。所有指针都是字对齐的（32 位），因此最低两位也是确定的。对于由 STS 运行时创建的对象，第一个字由指向虚函数表表的指针占用。&lt;/p&gt;
&lt;h3&gt;3.4 虚函数表布局（Virtual table layout）&lt;/h3&gt;
&lt;p&gt;与 Java 或 C# 相似的是，STS 类的编译具有单继承和静态内存布局（static memory layout）的特点。对象的第一个字（word）指向一个虚函数表，随后的字被分配给字段（如果有基类的字段，会放在前面）。虚函数表包含对象的空间、静态分配的类的序号（包括 STS 支持的内置类型和用户定义的类型的标记）、一个指向接口表和接口哈希表的指针（见下文），该指针之后是指向方法的指针。&lt;/p&gt;
&lt;p&gt;最开始的四个方法插槽（slots）是为与对象标记和释放相关的运行时和 GC 相关的功能预先分配的，这些函数遵循 C++ 调用的约定。而其余的函数则遵循 STS 的调用约定。第一个 STS 方法指针是&lt;code class=&quot;language-text&quot;&gt;ToString()&lt;/code&gt;，前提是它已经被定义了。（注 7：&lt;code class=&quot;language-text&quot;&gt;ToString()&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;valueOf()&lt;/code&gt;在 JavaScript 运行时语义转换中扮演了特殊的角色，我们暂时还不支持&lt;code class=&quot;language-text&quot;&gt;valueOf&lt;/code&gt;）而之后是基类定义的方法，再之后是现有的类的方法。如果一个方法从未被动态调度（dynamic dispatch）所调用（例如，从未被重写或从未调用），则该方法不会被加入虚函数表（在 MakeCode Arcade 有引擎中，只有 13%的方法使用动态调度）。&lt;/p&gt;
&lt;p&gt;接口表按之前定义的顺序包含类的所有字段和方法的描述符。每个描述符都包含成员索引（分配给成员的名称）和一个函数指针。字段描述符还包含字段的偏移量。该描述符用于成员的查找和对象属性的迭代（如使用&lt;code class=&quot;language-text&quot;&gt;Object.keys()&lt;/code&gt;）。描述符用一个简单的哈希表索引，它通过成员索引乘以从虚拟表中获取的接口哈希乘数（在编译时按类计算）来计算键名。&lt;/p&gt;
&lt;p&gt;STS 使用三种成员查找方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当接收方为静态的类&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;时，编译器将针对 C 进行运行时子类型检查（有可能不成功，因为动态类型可能不是&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;的子类型），然后在虚函数表中用直接偏移量查找方法，或者在对象中使用直接偏移量进行字段访问。&lt;/li&gt;
&lt;li&gt;如果接收方动态时属于类（静态时可以是接口、&lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;或更复杂的结构类型），则使用成员索引和接口哈希键命在接口表中查找成员描述符。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于在 C ++运行时中实现的对象，使用特定于类型的函数，尤其是在编译对象文字或&lt;code class=&quot;language-text&quot;&gt;new Object()&lt;/code&gt;时使用的动态映射。&lt;/p&gt;
&lt;p&gt;4.3 节会对比着三种方法的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.5 算术运算符&lt;/h3&gt;
&lt;p&gt;一些算术运算符被编写为快速整数路径的汇编提高运行速度；以下是运算符&lt;code class=&quot;language-text&quot;&gt;+&lt;/code&gt;的实现：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;assembly&quot;&gt;&lt;pre class=&quot;language-assembly&quot;&gt;&lt;code class=&quot;language-assembly&quot;&gt;_numops_adds:
    ands r2, r0, r1 ; r2 := r0 &amp;amp; r1
    ands r2, #1 ; r2 &amp;amp;= 1
    beq .boxed ; last bit clear?
    subs r2, r1, #1 ; r2 := r1 - 1
    adds r2, r0, r2 ; r2 := r0 + r2
    bvs .boxed ; overflow?
    mov r0, r2 ; r0 := r2
    bx lr ; return
.boxed:
    mov r4, lr ; save return address
    bl numops::adds ; call into runtime
    bx r4 ; return&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它由特别实现的算术运算符有&lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;|&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;&amp;amp;&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;^&lt;/code&gt;和整数转换（调用 C++ 运行时函数时使用）。这些特别的汇编程序比始终调用 C++ 函数要快约两倍。我们在 4.3 节对乘法的性能做了比较。
除此之外的运算符则用 C++ 实现为使用整数、限制范围的数值和其它类型的抽象值的函数。&lt;/p&gt;
&lt;h3&gt;3.6 内置对象（built-in）的表示&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数组（Arrays）&lt;/strong&gt; 和 C++标准向量（vector）类似，但有相对保守的增长策略并且不支持稀疏数组（sparse array）。包括范围检查在内的简单数组访问操作用用汇编实现。设计索引转换和数组增长的情况用 C++ 运行时处理。缓冲区只是具有汇编字节访问器和用 C ++ 实现的许多实用程序函数的内存连续块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串（Strings）&lt;/strong&gt; 会有四种不同的表示，它们的开头都毁有一个虚函数表（v-table）指针。所有的字符串当前被限制为最大占用 65,535 字节的空间。ASCII 字符串（所有在 0-127 范围内的字符）用长度前缀加 NUL 中止的字符数据表示（其内部仍然可以有 NUL，只是为了方便 C++ 函数使用所以添加最后的 NUL）。较短的 Unicode 字符串使用 UTF-8 的可变长度编码，它们拥有不同的虚函数表。索引方法可以即时解码 UTF-8。&lt;/p&gt;
&lt;p&gt;更长的 Unicode 字符串表示为字符串的长度（以字符为单位）、字符串的大小（以字节为单位）以及指向数据的指针，该指针包含 UTF-8 中的实际字符数据（再次以 NUL 终止）和跳过列表 包含每个可被 16 整除的字符偏移量的字节偏移量。索引方法从最接近的前一个跳过列表偏移量开始，然后从那里开始对 UTF-8 数据进行解码。此编码用于代替标准 UTF-16，以节省空间。它还可以确保所有字符串（以下所述的临时字符串除外）都包含有效的 UTF-8 NUL 终止的字符串，从而使 C++ 运行时函数无需附加转换即可轻松处理它们。&lt;/p&gt;
&lt;p&gt;最后，当两个长字符串连接在一起时分配 cons-string。它们由两个指向字符串的指针组成（它们本身可以是 cons-string）。 当 cons-string 被索引时，它就地转换为一个跳过列表字符串（它们都是 12 个字节）。这使得字符串连接（在 JavaScript 中非常常见）成为了恒定时间操作。这是一种已经广泛使用的优化技术[4]，所有主要的 JavaScript 引擎都支持这项技术。&lt;/p&gt;
&lt;p&gt;前三种字符串是由编译器在内存中进行的，而所有四种字符串都可以动态构造。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包（Closures）&lt;/strong&gt; 用指向函数静态代码的指针表示，这些代码包含从外部作用域能获取的只读本地变量（不包含最外层的全局变量）。如果一个变量被获取后可以写入，它将转换为只想保存其值的堆对象的指针（在任何作用域中）。在闭包执行期间，会静态分配一个特定的寄存器来保存指向闭包对象的指针。&lt;/p&gt;
&lt;p&gt;函数会像值一样被使用，但不会获取任何东西，在闪存中以上述的格式静态分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态映射（Dynamic maps）&lt;/strong&gt; 是简单的两个向量，其中一个为键名，另一个为值。查找是线性的。&lt;/p&gt;
&lt;h3&gt;3.7 窥孔优化（Peep-hole optimizations）&lt;/h3&gt;
&lt;p&gt;在完成代码生成之后，生成的汇编代码会经历一次简单的窥孔优化。我们会用对生成的代码运行脚本，识别要被优化的特定指令序列，该脚本会识别到 2-3 条指令序列，并按它们出现的次数进行排序，然后对最常出现的指令序列检视是否能进行简化。典型的窥孔优化规则如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;assembly&quot;&gt;&lt;pre class=&quot;language-assembly&quot;&gt;&lt;code class=&quot;language-assembly&quot;&gt;push {lr}; push {X, ...} -&amp;gt; push {lr, X, ...}
pop {X, ...}; pop {pc} -&amp;gt; pop {X, ..., pc}
push {rX}; pop {rX} -&amp;gt; nothing
push {rX}; pop {rY} -&amp;gt; mov rY, rX
pop {rX}; push {rX} -&amp;gt; ldr rX, [sp, #0]
push {rX}; ldr rX, [sp, #0] -&amp;gt; push {rX}
push {rX}; movs rY, #V; pop {rX} -&amp;gt;
movs rY, #V (when X != Y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于分支，编译器始终会生成一个完全通用但繁琐的指令序列，然后由窥孔优化器简化。以&lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;在短跳范围举例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;assembly&quot;&gt;&lt;pre class=&quot;language-assembly&quot;&gt;&lt;code class=&quot;language-assembly&quot;&gt;beq .skip; b X; .skip: -&amp;gt; bne X&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事实上，&lt;code class=&quot;language-text&quot;&gt;b&lt;/code&gt;本身也有着范围的限制并且有时候需要使用&lt;code class=&quot;language-text&quot;&gt;bl&lt;/code&gt;来完成。相关的评估请参阅 4.3 节。&lt;/p&gt;
&lt;h3&gt;3.8 垃圾回收器&lt;/h3&gt;
&lt;p&gt;STS 运行时拥有一个定制、简洁、精确、紧凑、标记清除（译者注：Mark and Sweep Algorithm，即标记清除算法）的垃圾回收器。运行时会追踪所有执行线程关于 STS 的堆栈。STS 堆栈仅包含上述的统一格式的值。在收集它们时，这些堆栈、全局变量以及 C++ 运行时动态注册的指针都被视作活动指针，还会对它们进行递归扫描，查找其它活动指针。所有对象都从一个指向虚函数表的指针开始，虚函数表具有确定对象大小的方法。垃圾回收不会产生额外的空间开销，虚函数表的最低位用于标记可访问对象，而大小算法（在 Cortex-M4 上，间接调用开销仅为 4-8 个时间周期）用于在扫描阶段标记堆。&lt;/p&gt;
&lt;p&gt;当一个 STS 函数首次调用时（会有一个 C++ 栈对应在下面），一个 per-thread 对象记录了 STS 栈指针，栈指针在 C++ 函数被调用前被储存。如果 C++ 函数又一次调用 STS（这种情况很少见），则会将链接列表片段（linked list segment）添加到每个 pre-thread 对象中。这些 per-thread 对象由线程调度器保留。&lt;/p&gt;
&lt;p&gt;为了避免堆内存变得碎片化，我们触发垃圾回收的次数比严格必要触发次数要多。特别要提到的是，在每次垃圾回收之后，我们将第一个周期的可用内存标记为可分配。当无法在此处分配对象时，将触发新的垃圾回收，可能会将“好”区的位置移动。之后，无论对象是否适合（新的）良好部分，我们都会对其进行分配。这有可能触发太多次回收，但是这可以限制堆内存碎片化，当在执行过程中稍后需要分配更大的对象（例如屏幕缓冲区）时，这是至关重要的。此外，由于目标单片机的内存相对较小且处理器速度较快，垃圾回收的代价相当低廉。&lt;/p&gt;
&lt;p&gt;C++ 代码可以分配常规的可用于 GC 的对象，然后在 STS 端使用，也可以将传统的&lt;code class=&quot;language-text&quot;&gt;malloc()/free()&lt;/code&gt;方法用于其他用途。这种&lt;code class=&quot;language-text&quot;&gt;malloc&lt;/code&gt;块使用特殊的编码，包括代替虚函数表指针的空间，并且直到将其释放后才进行回收。这种堆内存的共享可以避免提前将内存拆分为 C++ 和 GC 堆。我们仍然保留一个小的 C++ 堆在中断服务程序中使用，因为 GC 不能在用在那里。&lt;/p&gt;
&lt;p&gt;除了寄存器之外，从 STS 调用的 C++ 函数的参数也放置在 STS 堆栈上，因此在函数运行时它们不会进行回收处理。 任何分配都可以触发垃圾回收，因此在 C++ 函数中分配的中间对象必须在返回给 STS 之前临时向垃圾回收器注册。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计数（Reference-counting）&lt;/strong&gt; 我们曾使用引用计数进行内存管理，会在执行期间增加对 C++ 函数的所有参数的引用计数。与上述垃圾回收过程相比，会相对产生巨大的时间开销（请参见图 7）。&lt;/p&gt;
&lt;h2&gt;4 性能评估&lt;/h2&gt;
&lt;p&gt;我们在一系列著名的小型性能密集型测试基准中评估了 STS 编译生成的机器码（又可以成为 STS 的虚拟机后端）的性能，并与以下的竞争对手做了对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种用 gcc 编译的纯 C 实现，用来做对比实验的基准（baseline）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Duktape 2.3&lt;/strong&gt;，一种嵌入式 JavaScript 解释器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IoT.js 1.0&lt;/strong&gt;，JerryScript 的嵌入式 JavaScript 解释器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 3.6&lt;/strong&gt;，寻常、成熟的 Python 解释器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.js 11.0&lt;/strong&gt;，包含了 V8 这种前沿的 JIT 引擎的运行时&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MicroPython 1.9.4&lt;/strong&gt;，一种嵌入式 Python 解释器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用三种不同的基于 ARM 的商用嵌入式系统进行测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GHI Brainpad&lt;/strong&gt;，使用 STM32F401RE 芯片, 拥有 96kB RAM、512kB 闪存和主频为 84MHz 的 ARM Cortex-M4F 核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adafruit Pybadge&lt;/strong&gt;，使用 ATSAMD51G19 芯片，拥有 192kB RAM、512kB 闪存和主频为 120MHz 的 ARM Cortex-M4F 核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树莓派 Zero（Raspberry Pi Zero）&lt;/strong&gt;，使用 BCM2835 芯片，拥有 512kB RAM 和恒定主频为 700MHz （关闭动态 CPU 主频调整）的 ARM11 核心。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树莓派可以运行 Node.js，所以超出了我们目标的内存范围，但我们使用它来作为 V8 的性能参考。通常来说，ARM11 核心的内存访问比 M4F 核心（整体 RAM 在性能上与 L1 缓存类似）的访问速度慢。M4F 核心上的 FPU 只是单精度的，所以么有用于基准测试。我们使用了 ARM11 上的 FPU。&lt;/p&gt;
&lt;p&gt;Duktape 使用 BCM 上的默认配置进行编译。在 STM 上，使用默认配置会立即耗尽内存，所以我们选用了适用于低内存配置文件（还启用了 fast integer 选项）。我们用的是官方的 ARMv6 Node.js 二进制文件。我们使用了 PiCore Linux 附带的 Python 环境。我们用过。我们使用了 STM32 的官方 MicroPython 二进制文件。&lt;/p&gt;
&lt;h2&gt;4.1 基准测试&lt;/h2&gt;
&lt;p&gt;我们使用下面的一系列基准测试。我们尝试使用在 TypeScript/JavaScript 和 Python 中对等的代码，然后对比运行时间而不是语言。（更具体地说，Python fann 使用的算法不同于 C 或 JavaScript 版本。我们将其更改，使它们使用相同的算法并直接进行数组访问。Python 二进制文件更改为使用类而不是元组。之所以进行这些更改，是因为我们想测试数组访问和类实现的性能。我们没有改变 richards 或 nbody 的实现）由于 C 程序内存不敢全并使用静态的整数表示形式，因此它们不一定具有可比性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Richards：&lt;/strong&gt;Martin Richard’s 基准测试模拟操作系统的调度程序队列。我们从 JetStream 基准套件[11]中获取 JavaScript 来源，并将原型初始化替换为等效的类代码，在需要的时候添加类型信息，从而将它们转换为 TypeScript 代码。该基准测试使用许多类以及用于不同调度程序任务的派生方法，用以测试对象属性访问性能。我们还使用了该基准测试的 C 和 Python 版本，它们使用单一结构以及 switch 语句和函数指针执行任务。 我们开发了等效的 TypeScript 代码（标记为 richards2），但是基于类的版本（richards）似乎可以更好地反映典型的 JavaScript 编码模式。 基准参数是数千次调度迭代的次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary trees：&lt;/strong&gt;该程序来自“计算机语言基准游戏”[10]。 在循环内，它分配给定深度的完整二叉树，对其执行简单的计算，然后将其解除分配。该基准测试用以测试内存分配子系统的性能。C、Python 和 TypeScript 版本来自 Benchmarks Game。为了更好地匹配 TypeScript 版本，我们将 Python 版本修改为使用类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fankuch redux：&lt;/strong&gt;这是基准测试游戏中的另一个程序，该程序计算特定排列的数量并测试数组访问和整数性能。我们修改了 Python 程序，以便于使用具有显式单元素数组访问的相同算法，与 C 和 TypeScript 版本对齐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;N-body:&lt;/strong&gt;这个程序是对太阳系中行星的物理模拟，也来自“基准游戏”，用于测量浮点性能。&lt;/p&gt;
&lt;h2&gt;4.2 STS 和 VM 的性能&lt;/h2&gt;
&lt;p&gt;图 4 对比了 STS 和其他环境的性能。我们将 C 程序的运行耗时直接用毫秒列出，其他的耗时则以比 C 程序慢多少的差值列出，以表示对 C 的敬意。&lt;/p&gt;
&lt;p&gt;在繁重的属性访问（二进制和理查兹）基准测试中，STS 比解释器快一个数量级，比 Node.js 慢不到两倍，而且解释器的内存耗尽要比二进制上的 STS 快得多。对于直接组合计算（fann），STS 比解释器快大约一个数量级，但比 Node.js（在 V8 中使用了相当先进的优化器）慢几倍。 在浮点计算（nbody）中，STS 仍比解释器快得多，但比 Node.js 慢 20 倍，后者更好地利用了 FPU。&lt;/p&gt;
&lt;p&gt;通常，运行时间越长的基准测试越能表明性能。 我们还包括了小迭代次数的结果，以便能够在同一程序上直接比较 BCM 和 STM。 在此类程序上，JIT 预热时间在 Node.js 结果中很重要。&lt;/p&gt;
&lt;p&gt;STS VM 比 ARM Thumb STS 慢 5-6 倍，除了重浮点 nbody 基准测试外，该基准测试的大部分工作都是在 C ++运行时函数中执行的。 但是，VM 仍然比解释器快得多，
这表明类的静态内存布局对整体 STS 性能有重要贡献。&lt;/p&gt;
&lt;p&gt;STM32 和 SAMD 上的结果差异很小（约 0.1％）。 在 BCM 上，我们运行了 10 次基准测试，并选择了最快的结果。&lt;/p&gt;
&lt;h2&gt;4.3 成员访问（member access）的性能&lt;/h2&gt;
&lt;p&gt;图 5 展示了各种形式的成员访问（请参阅 3.4 节）的耗时测算，表格的前四行是循环进行对&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;字段访问、具有动态子类型检查的访问、通过接口查找的访问、对动态银蛇对象访问的耗时。&lt;/p&gt;
&lt;p&gt;对于函数，本图列举了直接调用、对非虚拟类方法（non-virtual）的调用、对虚拟类方法的调用、对接口的调用。我们也区分了是否在&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;上调用，因为这样调用不需要进行动态类型检查，其他的非接口调用也是这样的。&lt;/p&gt;
&lt;p&gt;子类型检查（subtype check）决定了变量的虚拟和非虚拟调用，它的执行方式有细微的不同，而最终对应的性能几乎一致。接口查找不需要类型检查（因为该方法是从调用它的对象的虚函数表中查找的），这让它的速度并没有落后常规调用很多。动态映射查找取决于对象字段的数量，但其它的耗时大多和输入没有关系。&lt;/p&gt;
&lt;p&gt;图 7 显示了完整基准测试中这些不同的访问成员方式的性能影响。 第一行（基准测试）列出了默认模式下的运行时间，在该模式下，类除了具有较慢的接口表外，还具有类似于 Java 的虚拟表，并且类的字段通过内存查找以静态计算的偏移量进行访问。&lt;/p&gt;
&lt;p&gt;第二和第三行显示了通过接口表查找方法和字段时发生的速度下降。第四行显示了将对象表示为具有线性查找的动态映射后的减慢速度，基准测试允许以非侵入方式启用此功能，而字段访问的减慢速度相当惊人，约为 2 倍。&lt;/p&gt;
&lt;p&gt;下一行显示了访问&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;的成员时删除动态子类型检查的效果（因为在输入方法时已经检查了其类型）。禁用此优化将使我们退回到动态查找
在方法上。禁用此优化将让我们回落到动态查找的方法。&lt;/p&gt;
&lt;p&gt;下一行将简单的标记清除垃圾收集器的性能与引用计数进行了比较（详情请参阅 3.8 节）。&lt;/p&gt;
&lt;p&gt;接下来，我们展示将参数转换折叠到辅助函数中的影响。虽然影响很小，但是节省了 Arcade 代码大小的 4％。 然后的数据展示了窥孔优化器的效果，该优化器在 Arcade 上节省了 14％的代码大小，并将性能提高了百分之几。&lt;/p&gt;
&lt;p&gt;最后一行测量了用来保护类抽象的所有动态子类型检查（在基准测试中中启用）的影响。这是我们为遵循 TypeScript 语义而付出的代价，其中强制转换始终是成功的，但成员访问可能会失败。&lt;/p&gt;
&lt;h2&gt;4.4 语言基础构造的性能&lt;/h2&gt;
&lt;p&gt;图 6 展示了各种语言基础构造的循环耗时测算。与图 5 的策略一样，我们为对美中基础构造操作一百万次，减去空循环所消耗的时间，然后将时间转换为主时钟周期进行比较。&lt;/p&gt;
&lt;p&gt;两个 M4 内核的性能结果非常相似，但不完全相同——在这两种情况下，程序都是在闪存中运行的，这比 RAM 慢得多，而且 MCU 缓存的方式也不同。BCM 的数组处理更糟，可能是因为主内存访问 在那里需要更多的周期，并且缓存并不总是能解决它。 于内存分配（包括 GC 的摊销成本）而言，这尤其明显，然后内存分配也支配了浮点运算。另外，ARM11 上没有硬件整数除法。&lt;/p&gt;
&lt;p&gt;整数除法和乘法目前在汇编中没有高速实现的方法（因为 ARM 单片机之间的差异），因此它们比加、减、位运算要慢。&lt;/p&gt;
&lt;h2&gt;4.5 MakeCode Arcade 的性能&lt;/h2&gt;
&lt;p&gt;图 2 中展示的 MakeCode Arcade 手持游戏比上世纪八十年代的原版 Arcade 游戏机快 100 倍。但是，当年的游戏是用汇编开发的，并且大量使用了图形加速（sprite 等）。另一方面，MakeCode Arcade 使用完全自动的垃圾回收的语言，并且提供了非常高级封装切对初学者友好的 API。而更复杂的游戏（如图 3 中的游戏）可以以 30 fps 运行； 根据我们的基准测算，嵌入式解释器的运行速度为 1-5 fps。&lt;/p&gt;
&lt;p&gt;我们还评估了 Arcade 游戏的代码大小。在 STS 编译器中，每个输入（JavaScript）语句会生成大约 37 个字节的 ARM Thumb 机器码，每个输入代码行大约生成 20 个字节的 ARM Thumb 机器码。需要注意的是，未使用的代码部分将被删除，因此生成的二进制文件中永远不会存在完整的游戏引擎。相比之下，使用专用 16/32 位编码的 STS 虚拟机可获得大约两倍的代码密度。&lt;/p&gt;
&lt;p&gt;C ++运行时占用了约 125kB 的闪存，而引导加载程序和内部文件系统的空间又占用了 64kB，因此程序和游戏资源还剩下约 320kB 的可用空间，这意味着用户应用程序（游戏引擎以外的程序）限制为 5-10k 行代码，就目前来看，这并不是一个很大的限制。&lt;/p&gt;
&lt;h2&gt;5 相关的工作&lt;/h2&gt;
&lt;p&gt;Safe TypeScript[13]和 StrongScript[14]都通过运行时类型检查支持了完整的 TypeScript 的类型系统。我们的工作最接近 StrongScript，因为 STS 使用类的名义解释（nominal interpretation）进行代码生成，且 STS 运行时会区分动态对象和类对象，分别生成 JavaScript 的&lt;code class=&quot;language-text&quot;&gt;{x=...}&lt;/code&gt;语法和&lt;code class=&quot;language-text&quot;&gt;new C(...)&lt;/code&gt;语法。&lt;/p&gt;
&lt;p&gt;STS 和 StrongScript 也有一些区别，首先，StrongScript 的类型系统保证在不存在向下转换的情况下，具体类&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;的变量引用名义上为&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;的子类型的对象或为&lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;。STS 使用 TypeScript 的类型推断和类型检查，没有做这方面的修改。在 STS 中，类&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;的变量会被动态检查（通过查找字段/方法），确定其值是否为类&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;的名义子类型。其次，STS 会删除强制类型转换，StrongScript 会在运行时对其进行检查，而如上所述，STS 会在取消引用时（成员/字段查找）执行检察。Strong 允许使用额外的属性拓展类的对象，而 STS 目前不允许进行这样的拓展。&lt;/p&gt;
&lt;p&gt;Hop.js[17]是一个拥有高级类型接口的静态编译器，它会将 JavaScript 程序转换为 Scheme，之后在使用 Bigloo 进行编译。据称在组合基准测试（例如&lt;em&gt;fann&lt;/em&gt;）测出的性能要好于 STS，而在&lt;em&gt;Richards&lt;/em&gt;上则稍差一些（但是，这些数字来自 x86 架构的处理器，我们根据相对于 V8 的数字进行估算，我们无法在 RPi 上进行测试）。&lt;/p&gt;
&lt;p&gt;SJS[5,6]是一个相似的系统，但它使用 Java 实现，同时生成的代码是 C 语言而不是 Scheme。同样，在组合基准测试上，它似乎比 STS 表现更好，而在 Richards 上，表现稍差。这些编译器都不适合在 Web 浏览器中运行。通常来说，这些编译器在可以推断静态类型时似乎能够生成非常有效的代码，而在无法编译时，它们会使用慢得多的运行时路径。另一方面，STS 表现出相当平滑且可预测的性能。这应该允许将来结合使用这些方法。&lt;/p&gt;
&lt;p&gt;除了我们所比较的嵌入式解释器外，还有其他的一些解释器，例如 XS7 [21]或 Espruino[23]。它们似乎具有相近类似的性能。&lt;/p&gt;
&lt;h2&gt;6 总结&lt;/h2&gt;
&lt;p&gt;Static TypeScript（STS）填补了嵌入式编译器中有趣的空白。STS 的工具链完全由 TypeScript 实现，使之可以在浏览器运行并能为覆盖大部分 TypeScript 功能的子集成成 ARM（Thumb）机器码。STS 利用类的名义类型解释（nominal interpretation）提高编译代码的效率。有赖于 MakeCode，STS 现已广泛运行在许多低 RAM 的设备上。一组对 STS 的小型基准评估表明，STS 生成的代码比各种脚本语言的嵌入式解释器的运行速度要快得多。迄今为止最大的 STS 应用程序是 MakeCode Arcade，其游戏引擎有超过 10,000 行 STS 代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;致谢&lt;/strong&gt; 我们要感谢 MakeCode 团队的成员和前成员：Abhijith Chatra、Sam El-Husseini、Caitlin Hennessy、Steve Hodges、Guillaume
Jenkins、Shannon Kao、Richard Knoll、Jacqueline Russell、Daryl Zuniga。我们还要感谢 Lancaster 大学的 James Devine 和 Joe Finney，他们开发的 CODAL 是 STS 的 C++运行时的一部分。最后，我们还要感谢匿名审稿人的评论，并感谢 Edd Barrett 帮忙润色本文的最终版本。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1]: Jonny Austin, Howard Baker, Thomas Ball, James Devine, Joe Finney,Peli de Halleux, Steve Hodges, Michal Moskal, and Gareth Stockdale. 2019. The BBC micro:bit – from the UK to the World. Commun. ACM(to appear) (2019).&lt;/p&gt;
&lt;p&gt;[2]: BBC. 2017. BBC micro:bit celebrates huge impact in first year, with 90% of students saying it helped show that anyone can code. &lt;a href=&quot;https://www.bbc.co.uk/mediacentre/latestnews/2017/microbit-first-year&quot;&gt;https://www.bbc.co.uk/mediacentre/latestnews/2017/microbit-first-year&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[3]: Gavin M. Bierman, Martín Abadi, and Mads Torgersen. 2014. Understanding TypeScript. In ECOOP 2014 - Object-Oriented Programming - 28th European Conference, Uppsala, Sweden, July 28 - August 1, 2014.Proceedings. 257–281. &lt;a href=&quot;https://doi.org/10.1007/978-3-662-44202-9_11&quot;&gt;https://doi.org/10.1007/978-3-662-44202-9_11&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]: 尽管我们可以使用 Emscripten 或类似的技术在本地对 C++ 进行编译，但编译工具链、头文件和相关的库可能需要数十兆的下载请求，导致浏览器的离线缓存空间紧张。&lt;/p&gt;
&lt;p&gt;[6] Wontae Choi, Satish Chandra, George Necula, and Koushik Sen. 2015.SJS: A type system for JavaScript with fixed object layout. In International Static Analysis Symposium. Springer, 181–198.&lt;/p&gt;
&lt;p&gt;[7] James Devine, Joe Finney, Peli de Halleux, Michal Moskal, Thomas Ball,and Steve Hodges. 2018. MakeCode and CODAL: intuitive and efficient
embedded systems programming for education. In Proceedings of the 19th ACM SIGPLAN/SIGBED International Conference on Languages,Compilers, and Tools for Embedded Systems, LCTES 2018, Philadelphia,PA, USA, June 19-20, 2018. 19–30.&lt;/p&gt;
&lt;p&gt;[8] Evgeny Gavrin, Sung-Jae Lee, Ruben Ayrapetyan, and Andrey Shitov.2015. Ultra Lightweight JavaScript Engine for Internet of Things. In SPLASH Companion 2015. 19–20.&lt;/p&gt;
&lt;p&gt;[9] Damien George. 2018. MicroPython. &lt;a href=&quot;http://www.micropython.org&quot;&gt;http://www.micropython.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[10] Isaac Gouy. 2018. The Computer Language Benchmarks Game. &lt;a href=&quot;https://benchmarksgame-team.pages.debian.net/benchmarksgame/&quot;&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[11] Apple Inc. 2018. JetStream Benchmarks 1.1. &lt;a href=&quot;https://www.browserbench.org/JetStream/in-depth.html&quot;&gt;https://www.browserbench.org/JetStream/in-depth.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[12] Adafruit Industries. 2018. CircuitPython. &lt;a href=&quot;https://github.com/adafruit/circuitpython&quot;&gt;https://github.com/adafruit/circuitpython&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[13] A. Rastogi, N. Swamy, C. Fournet, G. M. Bierman, and P. Vekris. 2015.Safe &amp;#x26; Efficient Gradual Typing for TypeScript. In Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. 167–180. &lt;a href=&quot;http://doi.acm.org/10.1145/2676726.2676971&quot;&gt;http://doi.acm.org/10.1145/2676726.2676971&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[14] G. Richards, F. Z. Nardelli, and J. Vitek. 2015. Concrete Types for TypeScript. In 29th European Conference on Object-Oriented Programming,ECOOP 2015. 76–100. &lt;a href=&quot;https://doi.org/10.4230/LIPIcs.ECOOP.2015.76&quot;&gt;https://doi.org/10.4230/LIPIcs.ECOOP.2015.76&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[15] Samsung. 2018. JerryScript. &lt;a href=&quot;http://jerryscript.org&quot;&gt;http://jerryscript.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[16] Sue Sentance, Jane Waite, Steve Hodges, Emily MacLeod, and Lucy Yeomans. 2017. “Creating Cool Stuff”: Pupils’ Experience of the BBC Micro:Bit. In Proceedings of the 2017 ACM SIGCSE Technical Symposium on Computer Science Education (SIGCSE ’17). ACM, 531–536. &lt;a href=&quot;https://doi.org/10.1145/3017680.3017749&quot;&gt;https://doi.org/10.1145/3017680.3017749&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[17] Manuel Serrano. 2018. JavaScript AOT compilation. In Proceedings of the 14th ACM SIGPLAN International Symposium on Dynamic Languages. ACM, 50–63.&lt;/p&gt;
&lt;p&gt;[18] Jeremy G. Siek and Walid Taha. 2007. Gradual Typing for Objects. In ECOOP 2007 - Object-Oriented Programming, 21st European Conference, Berlin, Germany, July 30 - August 3, 2007, Proceedings. 2–27. &lt;a href=&quot;https://doi.org/10.1007/978-3-540-73589-2_2&quot;&gt;https://doi.org/10.1007/978-3-540-73589-2_2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[19] Artifex Software. 2018. MuJS. &lt;a href=&quot;https://mujs.com/&quot;&gt;https://mujs.com/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[20] Cesanta Software. 2018. mJS. &lt;a href=&quot;https://github.com/cesanta/mjs&quot;&gt;https://github.com/cesanta/mjs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[21] Patrick Soquet. 2017. XS7. &lt;a href=&quot;https://www.moddable.com/XS7-TC-39&quot;&gt;https://www.moddable.com/XS7-TC-39&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[22] Sami Vaarala. 2018. DukTape. &lt;a href=&quot;https://duktape.org/&quot;&gt;https://duktape.org/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[23] Gordon Williams. 2017. Making Things Smart: Easy Embedded JavaScript Programming for Making Everyday Objects into Intelligent Machines. Maker Media.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[译文：为什么 ML/OCaml 适用于编译器开发（1998）]]></title><description><![CDATA[作者: Dwight VandenBerghe 电邮地址: dwight@pentasoft.com 日期: 1998/07/28 让我们用“ML”系列来指代 SML 或 Objective Caml 等语言。我是 OCaml 的拥簇，虽然我更喜欢 OCaml…]]></description><link>https://tsangkalung.github.io/ml-writing-compilers/</link><guid isPermaLink="false">https://tsangkalung.github.io/ml-writing-compilers/</guid><pubDate>Tue, 17 Nov 2020 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;作者:&lt;/strong&gt; Dwight VandenBerghe&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电邮地址:&lt;/strong&gt; dwight@pentasoft.com&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日期:&lt;/strong&gt; 1998/07/28&lt;/p&gt;
&lt;p&gt;让我们用“ML”系列来指代 SML 或 Objective Caml 等语言。我是 OCaml 的拥簇，虽然我更喜欢 OCaml 的发行版、工具链和总体实现，但我也同时使用 SML/NJ。在不能使用 OCaml 的情况下，我会很乐意用 SML/NJ 进行开发（我并不青睐 Haskell、Gofer、Hugs 等惰性求值语言；人的喜好不同，有人偏爱延迟求值（Deferred Evaluation），也有人更喜欢严格值传递，我的喜好则属于后者。我喜欢严格求值的清爽和了解每一步动作的便利，这是我为什么放弃 Haskell 的原因）。本文中用 ML 来指代，但同样适用于 OCaml 和 SML/NJ 这一类语言。&lt;/p&gt;
&lt;p&gt;我列出来的这类语言会让编写编译器不再枯燥乏味，反而会变成一件趣事。&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收（GC）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GC 听起来非常基础，但它对有很多较短生命周期的复杂数据结构的程序非常重要。首先，编译器就是一个充满复杂数据结构的程序，如果你喜欢编译器，那你肯定着迷于数据结构。C/C++、Pascal 等语言用智能指针或&lt;code class=&quot;language-text&quot;&gt;malloc&lt;/code&gt;等手段让程序员可以手动进行垃圾回收，程序员也扮演着垃圾清道夫的角色，甚至有时候清道夫的角色会多过程序员的角色。而 ML 或许具有最好的 GC 功能，在实际运用中，ML 的 GC 速度足以与 C++的&lt;code class=&quot;language-text&quot;&gt;malloc/free&lt;/code&gt;匹敌，有时候甚至会更快。在使用 ML 的 GC 时我们不必花费精力，就像在使用 Java 一样，但 Java 的 GC 更慢。ML 的 GC 非常自然、高效、稳定，让我们的开发更加轻松。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优化的尾递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦懂得利用它，就可以编写不占用过多栈空间的快速树遍历。当前，有些 C++编译器（例如 Visual C++ 5）据说已经进行了部分尾递归优化，但不能指望它们（VC 中有许多错误）。ML 非常适合编写递归，又因为编译器中的许多数据结构都能利用递归进行很好的处理，因而 ML 非常适合编写编译器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ML 的数据类型适合编译处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器无需担心&lt;code class=&quot;language-text&quot;&gt;unsigned short&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;signed char&lt;/code&gt;，而可以只使用&lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt;（对字符串也一样）。在 C/C++中，&lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt;被广泛使用，而即使有模板类型，C/C++中的字符串类型也相当糟糕。在开发编译器时我们会遇到算术运算需要比&lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt;范围更大的数值进行运算(例如常量折叠，又或者是把基础数值类型向更精确的类型进行 tokenize，然后再转回原来的形式)，这时候就需要&lt;code class=&quot;language-text&quot;&gt;bignum&lt;/code&gt;了。如果这时候没有&lt;code class=&quot;language-text&quot;&gt;bignum&lt;/code&gt;，那么我们需要自己进行对应的实现，或者用其它的奇技淫巧。（这方面更详细的例子可以参阅了不起的编译器作者 Dave Hanson 写的《C
Interfaces and Implementations》[1]）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ML 的类型构造器非常适合描述类似 AST（抽象语法树）的结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它们实现了 tagged unions（标签联合）[2]，这是一种比 C/C++的 union 小巧而高效的 union 数据类型；它带有标签字段标记 union 中的类型，并且标签字段是强制使用的。在 ML 中，tagged union 与模式匹配一起使用，因此以数据结构为参数的函数的代码可读性会非常好。再结合类型推导和尾递归优化，ML 对采用复杂数据结构的递归函数进行了针对性优化。听起来有些耳熟是吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 被认为是数学家进行自动化定理证明的解决方案，因为这一领域的常用语言（Lisp）具有无类型、危险、灵巧的特性，导致不能确定程序是否能正常工作。ML 对此加上了一些限制来提高效率和安全性；ML 程序不会导致系统崩溃，如果它正确完成了编译，那么它就会正常运行，可以保证不会发生普通的类型错误。比如，&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;是不可变的（immutable），并且只能包含一种类型的元素，因此不必担心意外将整数放入字符串&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;导致字符串&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;出错（就像使用 Scheme 和 Lisp 时常发生的错误）；在 ML 中，我们无法更改&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;中的内容，必须创建一个新&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;进行替换，这使得底层运行时比其他语言中的&lt;code class=&quot;language-text&quot;&gt;List&lt;/code&gt;要快得多，在其他语言中，您必须担心双向链表、破坏性更新等。再搭配上默默工作的快速 GC 系统，这一切是如此的自然…让我们可以早些下班。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ML 是为了单独的应用领域（即自动化定理证明[3]）而设计的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一领域的特点是有庞大、棘手、递归的数据结构，它们有着与之对应的复杂算法。听起来有些耳熟是吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异常处理（Exceptions）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 实现了快速且整洁的异常处理，让开发者在使用它们时没有心智负担。假设要开发一个使用键名的表查找程序，我们会把查询功能代码放在&lt;code class=&quot;language-text&quot;&gt;try&lt;/code&gt;的代码块中并且在&lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;中捕获未查找到键名的异常。这样就不用担心未测试出未查找到键名的情况下程序崩溃，如果真的发生这样的异常，运行时会抛出异常消息并告知异常发生的具体位置。当我们学会使用异常处理后，程序会变得更加容易调试、整洁、鲁棒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类型接口（Type Interface）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常在一千行 ML 代码中我们只需要声明两三个变量。ML 通过如何使用变量来确定类型，它不会像 Perl 那样进行类型推导，它的类型是确定的。我喜欢 OCaml 多过 SML 的其中一个原因是 OCaml 不会进行运算符重载：例如，浮点加法(+.)和整数加法（+）的运算符是不同的。类型接口和运算符重载像是同床异梦的床伴，语言的设计者应该在两者之间做出取舍，而不是同时兼容二者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lex/yacc/burg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 对于这些编译器工具有很好的支持。当开始上手这些工具后，你会发现它们会让许多工作变得更轻松。我不是 Lex 的粉丝，也并不喜欢 lalr(1)多过 ll(k)，但我是一个实用主义者，如果有这样被良好实现的工具我会毫不犹豫地使用。OCaml 和 SML/NJ 都拥有很不错的编译工具实现供开发者使用。像这样提供优良工具链的语言并不多见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;忘了说，OCaml 非常的快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我用 OCaml 编写了一种精算财务建模语言的编译器。它大概有一万行代码，但倘若使用 C++则可能需要两万行以上的代码。它可以在奔腾 200 处理器的机器上在 3 秒内编译现有最大的程序，而大多数程序只需不到一秒就可以完成编译，这使我感到非常惊讶。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持（Support）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其它语言的维护者相比，Inria（Xavier Leroy 和 Pierre Weis 等人）提供了更好的支持。关于语言的疑问通常不会太多，我遇到的一些问题在几天之内就得到他们的支持得以解决，这比 VC++或 Turbo Pascal 的支持快很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;库（Library）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 的标准库包含许多实用的数据结构，比其它语言的相对混乱的标准版更加完整、简洁和实用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块系统（Module System）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ML 对单独的编译具有优异且设计优良的支持，从而让单独编译的模块也可以支持多态（对任意的类型进行操作）。而模块内部的可见性也是完全可控的。Functor 可以让模块特化为特定的实例，就像没有恼人的 C++ 模板一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;所以主要的问题是数据结构。ML 非常适合定义复杂数据结构和围绕它们的递归算法。ML 对最基本的数据结构（如列表、数组、结构、联合体、哈希表、二叉树、队列等）提供了良好支持。可以以此为基础方便地构造出另一门全新的语言。&lt;/p&gt;
&lt;p&gt;ML 是一种完美的语言吗？答案是否定的。和其它的语言一样，它也有很多缺陷：ML 的语法有些晦涩、类似&lt;code class=&quot;language-text&quot;&gt;printf&lt;/code&gt;这样的简单功能写出来很奇怪……在很多领域 ML 都不能适用（比如我投入很多精力的嵌入式系统开发），例如，在 DSP 芯片上用 ML 来写 FFT 算法将是一场噩梦；据我所知，ML 也不适用于 GUI 开发；ML 也缺少对面向对象的支持（尽管我觉得这是 ML 的特性而非缺陷）。但所有语言都有它们适合发光发热的领域，而我认为编译器开发就是 ML 的适用领域之一。这种感觉就像你在编写编译器的其中一个函数时突然需要一个 9mm 的螺丝扳手，打开 ML 的工具箱，在箱子的抽屉里就有一个顺手的扳手；又过了几分钟，又需要一个磁吸十字螺丝刀时，工具箱里恰好也有一把顺手的螺丝刀。这不是说 ML 的工具箱里有大量工具（事实上，ML 的工具箱比其它的工具箱小得多），因为工具箱由一群能工巧匠经过深思熟虑打造而成的，他们汲取了数十年的经验，对所有好的工具进行了专门设计，目的是打造快速、安全、健壮的程序对复杂数据结构进行递归操作。&lt;/p&gt;
&lt;p&gt;这些程序，就是编译器。&lt;/p&gt;
&lt;p&gt;Dwight&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译者注：&lt;/strong&gt;
[1]: read.pudn.com/downloads547/ebook/2256772/CInterfacesandImplementation/C%20Interfaces%20and%20Implementations.pdf&lt;/p&gt;
&lt;p&gt;[2]: In computer science, a tagged union, also called a variant, variant record, choice type, discriminated union, disjoint union, sum type or coproduct, is a data structure used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a tag field explicitly indicates which one is in use. It can be thought of as a type that has several “cases”, each of which should be handled correctly when that type is manipulated. This is critical in defining recursive datatypes, in which some component of a value may have the same type as the value itself, for example in defining a type for representing trees, where it is necessary to distinguish multi-node subtrees and leafs. Like ordinary unions, tagged unions can save storage by overlapping storage areas for each type, since only one is in use at a time.&lt;/p&gt;
&lt;p&gt;[3]: Automated theorem proving (also known as ATP or automated deduction) is a subfield of automated reasoning and mathematical logic dealing with proving mathematical theorems by computer programs. Automated reasoning over mathematical proof was a major impetus for the development of computer science.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[About]]></title><description><![CDATA[Tsang Ka-Lung(in Cantonese) is a ECE student in Beijing University of Posts and Telecommunications.This weblog is his tech-dairy. Learn more…]]></description><link>https://tsangkalung.github.io/about-me/</link><guid isPermaLink="false">https://tsangkalung.github.io/about-me/</guid><pubDate>Sat, 27 Jul 2019 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;Tsang Ka-Lung(in Cantonese) is a ECE student in Beijing University of Posts and Telecommunications.This weblog is his tech-dairy.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Learn more about him, please by the following ways.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/TsangKalung&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.instagram.com/kalung_tsang&quot;&gt;&lt;strong&gt;Instagram&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.douban.com/people/Kalung_Tsang&quot;&gt;&lt;strong&gt;Douban&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[北京的夜雨]]></title><description><![CDATA[…]]></description><link>https://tsangkalung.github.io/beijing-rain/</link><guid isPermaLink="false">https://tsangkalung.github.io/beijing-rain/</guid><pubDate>Sat, 27 Jul 2019 07:26:03 GMT</pubDate><content:encoded>&lt;p&gt;刚刚在豆列里看到她写的日记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;北京至广州的高铁的沿线风景，应数湖南境内最佳。湖南的景色，是独集山丘，秀木，丛林，田野，水塘，炊烟人家于一身，且有着赏心悦目的搭配，构成上佳组合，夕阳播下，更是笼罩了一层金色的光晕。这景怎么赏得完！可惜树林与隧道颇多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这在铁道友中已是广泛的共识，我也曾和很多人提起过。但是这是一个法语专业的女生，如果她也这样认为，那么我会相信这是一种普罗的看法或体验。在冬天回家时，乘坐 G79 次列车会是一种很奇妙的体验：北京的温度是-10 摄氏度，terminal 的温度是 25 摄氏度。这样的温差意味着你会在两千余公里的旅途中历经四季的变换。&lt;/p&gt;
&lt;p&gt;说些题外话，我觉得北京最美的季节是秋季:绚烂的季节将街道染成金黄色，落下的银杏叶渐厚地堆叠着，人们踏着落叶享受着清爽的秋风。这种冲击感在我看来，对于初次见到的人是一种高于感官阈值的体验——在从小长大的地方，秋也许只意味着一丝十几天长的微妙的凉意，但突然尝饱、赏尽这溢出眼眶的秋色，却让人有些不适应。陶然亭的芦花、钓鱼台的夜柳、颐和的明月，当然还有学院路的同学在欣赏铺满银杏的校道，这一切无不让人感到心旷神怡。银杏叶的弧度和缺口是天造的美学，透过斑驳的叶影，你能看到群青色的天空——蓝到不真实、蓝到有些发紫，这也是在岭南看不到的，岭南的蓝天是克制的水蓝色。&lt;/p&gt;
&lt;p&gt;但倘若到了冬季，一切美仿佛都褪去了。华北平原是这样的严酷萧瑟，以至于你看不到黑与白之外的颜色，人们的羽绒服只有黑白灰色，树林只剩下树杈，天空只飘过锅炉的雾气。有时候觉得在小路旁种着杨树真是很愚蠢的事情，杨树真是我见过最可恶的植物：春天飘出杨絮，夏天最盛时也没有几片叶子，甚至，它的绿色也是一种加了灰度的绿色，到了冬天时只剩下徒增忧愁的小树丫，两排伫立在行道旁。这样的萧瑟会持续非常漫长的一段时间，人也变得非常的忧郁，有时候甚至会对着图书馆窗外的「灰」森林留下眼泪。这样的冬天不仅凌冽在颜色的匮乏上，更摄人心魂的是从遥远的西伯利亚吹来的朔风，但说实话，这是伤感的冬天中唯一让我感到喜欢的事物——冷风让人无比清醒，让人感到「実感」，让人无比精神，让人觉得灵魂在自己的完全掌控下。&lt;/p&gt;
&lt;p&gt;忧伤冬天的结束的契机，就是跳上 G79 次列车之时。你会觉得终于和这个凌冽的冬天告别了，回到时常想念的天气预报里永远气温二三十度的南海之滨。于是奇妙之旅开始了，一切发生在短短的八小时里；第一个小时，窗外依然是严酷的塞外之景，一片灰霾笼罩的萧索，华北平原如同唐人所咏的军旅塞外诗；经过郑州之后，景色慢慢开始不同：漂泊着浮冰的黄河上还有人在撑船，黄河在冬天并不是黄色，而是一种黑褐色；第四个小时，在武汉，终于看到了冬天的第一场雪，雪花附在松树上不愿化去，长江显得有些汹涌，街道上熙熙攘攘；当穿过湘南粤北的重重隧道后，芭蕉叶开始显现，第一次来到岭南的乘客开始惊叹这种与人同高的大叶子，木瓜树和芋叶也密布在河网中；对我而言：经过朔方的雄奇、黄淮的克制、荆楚的初雪之后，终于回到了毓秀的岭南；经过苦寒后，终于回到了没有季节的地方。在古代，京城出发的千里驿马跑到这里已疲倦不堪，而远航到南洋的海船正时刻准备拔错出发。&lt;/p&gt;
&lt;p&gt;当然，岭南的翠绿和北国之秋的金黄一样，也是远远超过人的感官阈值的：时隔半年再次看到孩子们在郁郁葱葱的草地上嬉戏打闹、老人们在数百年已成林的榕树下吟唱《荔枝颂》、青翠从脚底的青苔一直延伸到远山的大王椰。我心中对岭南的剪影是这样的：在马赛克装饰的骑楼中，摆放着古色古香的明清木家具和功夫茶具，窗外是有些让人感到惊奇的棕榈和榕树。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 560px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f0b774a549aa99358bc99edc554fae90/9342c/jingguang.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 297.9729729729729%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAA8ABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMCAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB96NYlwYzWBdwZxrq7CI1HQf/xAAdEAABBAMBAQAAAAAAAAAAAAACAAEDMhARIRIg/9oACAEBAAEFAkLu5LW1FRHWOmIuMi4INxSUDXnEfz//xAAUEQEAAAAAAAAAAAAAAAAAAAAw/9oACAEDAQE/AQ//xAAUEQEAAAAAAAAAAAAAAAAAAAAw/9oACAECAQE/AQ//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAQIFECMXH/2gAIAQEABj8CnLWPagsjRokRtuioFZ9x/8QAHhAAAgICAwEBAAAAAAAAAAAAAREAIRAxQVFhcYH/2gAIAQEAAT8hhkZWgD3zFCGwcOvk/Yzr6RawgtPBaggCjU/MGQAUHcXtt8NYtHiWeqwaFQUD1eusEwAbjn//2gAMAwEAAgADAAAAEOfMTJDCfP/EABkRAQACAwAAAAAAAAAAAAAAABARQQEhMf/aAAgBAwEBPxDHCiidQf/EABQRAQAAAAAAAAAAAAAAAAAAADD/2gAIAQIBAT8QD//EACAQAQEAAgICAgMAAAAAAAAAAAERACExUUFhcYGhsfH/2gAIAQEAAT8QQ4/GGGgSND+D6cKKt+HNWQG77xk6Sg0mq5PTI7ZHhfGaK+UVahgKeMCQMZpnGcNgSG4E/c+snq5XAZdoes3NCGACzwHE4y3vCxURHKqMMpYsJuwmM8szYRYcYSFTy9bdce/vF6LinWE0AXblZ//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;roadmap&quot;
        title=&quot;roadmap&quot;
        src=&quot;/static/f0b774a549aa99358bc99edc554fae90/9342c/jingguang.jpg&quot;
        srcset=&quot;/static/f0b774a549aa99358bc99edc554fae90/a80bd/jingguang.jpg 148w,
/static/f0b774a549aa99358bc99edc554fae90/1c91a/jingguang.jpg 295w,
/static/f0b774a549aa99358bc99edc554fae90/9342c/jingguang.jpg 560w&quot;
        sizes=&quot;(max-width: 560px) 100vw, 560px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，这两千余公里旅途中最美的一段如开头所说，是京广高铁湖南的一段——严格来说：长沙以南，韶关以北。我其实不太认同江韵说「隧道颇多」是一个遗憾，反而觉得这一段路程多隧道是锦上添花。在高速奔驰的列车中，你觉得路途遥远却耳熟能详的一个又一个都市被一个小时一个小时地快速掠过，本已是一种乘坐飞机无法体验到的感觉；但在穿过第一个隧道之后，你会发出「哇」的一声惊叹。在瑰丽的群山的环抱中，是一片广袤的盛开着的油菜田，我看到一群孩子在其中追逐——然后，高速的列车冲入下一个隧道，我在心中莫名觉得隧道变成了一幕幕表演中间的幕布，果不其然——通过隧道后是像桃花源一样的小村，土地平旷，阡陌交通，规整娟秀的村舍坐落在青绿的农田的包围中，飘出袅袅炊烟，这是多少人渴望的归田园居。穿过下一个隧道，则发现列车在数十米高的桥梁上，而一边的山势陡峭，翡翠色（没有夸张）的溪流汇入谷底，变成一条小溪。远处可以看到一座断桥，那是詹天佑修筑的粤汉铁路的遗址——此处为湖南和广东的省界。穿过无数个隧道之后，迎接你的是无尽的绿意和暖湿粘腻的空气——是这样的不同——在几个小时前你吸入胸腔的还是西伯利亚吹来的清冷干冽的冬风。中国有许多景色出众的铁路，但这一段绝对是其中最特别的：经历最长的路程、四个季节的变换，穿越于两个世界之间，以及属于潇湘的特别。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回忆起这些，窗外是北京的夜雨。&lt;/p&gt;</content:encoded></item></channel></rss>