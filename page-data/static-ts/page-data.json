{"componentChunkName":"component---src-templates-blog-post-js","path":"/static-ts/","result":{"data":{"site":{"siteMetadata":{"title":"Tsang's Blog"}},"markdownRemark":{"id":"3eee099a-678c-57a0-9494-73fa9cd2ab44","excerpt":"译者声明：本译文获得原作者授权翻译。 作者： Thomas Ball，微软研究院，Redmond，tball@microsoft.com Peli de Halleux，微软研究院，Redmond，jhalleux@microsoft.com Michał Moskal，微软研究院，Redmond，mimoskal…","html":"<p>译者声明：本译文获得原作者授权翻译。</p>\n<p>作者：</p>\n<ol>\n<li><strong>Thomas Ball</strong>，微软研究院，Redmond，tball@microsoft.com</li>\n<li><strong>Peli de Halleux</strong>，微软研究院，Redmond，jhalleux@microsoft.com</li>\n<li><strong>Michał Moskal</strong>，微软研究院，Redmond，mimoskal@microsoft.com</li>\n</ol>\n<h2>综述</h2>\n<p>基于单片机的嵌入式设备通常使用 C 语言进行编程。这类设备如今进入了计算机科学教学的课堂，甚至一些中学也开办了相关的课程。于是，用于单片机编程的脚本语言（如 JavaScript 和 Python）使用也逐渐增加。</p>\n<p>我们研发了 Static TypeScript（STS），它是 TypeScript 的一种子集（而 TypeScript 本身是 JavaScript 的超集），还研发了相关的编译/链接工具链，它们全部使用 TypeScript 进行开发并且在浏览器中运行。STS 为实践而设计（特别是实践教学），适合针对小型设备的静态编译。用户编写的 STS 程序将在浏览器中被编译成机器码，并链接预编译的 C++运行时，生成比普通的嵌入式解释器更高效的可执行文件，从而延长电池寿命并可以在 RAM 低达 16kB 的设备上运行（例如 BBC micro:bit）。本论文主要对实现 STS 系统和适用于课堂教学的嵌入式编程平台的技术挑战进行综述。</p>\n<p><strong>关键词：</strong>JavaScript，TypeScript，编译器，解释器，单片机，虚拟机</p>\n<h2>1 简介</h2>\n<p>近来，课堂上计算机的实物教学不断地发展，鼓励孩子们构建自己的简单的交互嵌入式系统。例如，图 1（a）展示了 BBC micro:bit[1]，它是一种受 Arduino 启发的小型可编程计算机，拥有集成的 5X5 LED 显示点阵、几个传感器和低功耗蓝牙（BLE）无线传输。该设备与 2015 年首次向英国所有 7 年级学生推出（10 至 11 岁），随后走向全球，迄今为止已经通过 micro:bit 教育基金会（ <a href=\"https://microbit.org\">https://microbit.org</a> ）发放了四百万个设备。图 1（b）则展示了另一个以 RGB LED 为特点的教育设备 Adafruit’s Circuit Playground Express (CPX)。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a99b064967e9368263d4f1bb52ca18e4/6c68b/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACl0lEQVQoz42T30uTURjH9590E12YqdgPIeb8semmU+fUaalzS53OX8nMJHelqERu60YDLZWEAgMLIrop6CI0KPBCSCIMSafl3HRb5tja3vfT66YTu+rAOZzzvN/n85xz3u+RIYr8TxMlnSAIybnf7yO460WIRhIxQYzHZTFpOPjpJ7zmJez249nysLrlZnvHh8e3h3c3QCgckcQJWGDXx6vn09x39jHvGOHF6CAb66vJQrLIQYRvheM4r3TSW9CJSdNEW5EFVXEteaVGspSVjE09iSf83vfjHLnNgNVArTqb3Avp9Gmq6Kkz8n11Ja6RRQIhbHIL57LUpOWVUVRQj7XQilxpIDO3nLNpedgHXXHx29fzWLs0mOpUKDIvcTklBUNuKd3ydiaG7yISQ+bdC6A3WVGV1pOVX4ne2EbBtUaKq5u5qqlBV9yAwzUZB05MOqiyVdBjs1BZqqVMXUSdwUB7pZ3+jiF8O25kHumOWpq70FcYycwpR2toQlNxg0K9iRzp2CW6Glzjj+LAmSkXyg49umo9WqWKfEU+NdoS6s3j9NucBPd+SEBphypFFecvakiTl6CWYPllRgr05niBM6kKuu8Mx4GfFt6hszWRWl1LlaEBvbac9LybZJU5mHgwk7hDn/TX7g1102KpZXigF3OjiZEhO5bWZgYH7XR2mnk2N0VMOLRGjKczY1Tf6iejyExGWjbKplHsUsHg7nYCGA4f4F6e5eviGOvL83z58JjNzy9ZWZxlbWmOlfcuNlffcOJWkaWPC7S0dmG83sz0xEPEaOjENoe+jkZF/kRjRKVtBH/ts7HhlubSOprogiAmE47BAb+fzU33KeMfAU+/lFAohMfj+fedJBOO9cFgEK/XdxQTkt/+AjhFnH73LZBpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"图1\"\n        title=\"图1\"\n        src=\"/static/a99b064967e9368263d4f1bb52ca18e4/fcda8/1.png\"\n        srcset=\"/static/a99b064967e9368263d4f1bb52ca18e4/12f09/1.png 148w,\n/static/a99b064967e9368263d4f1bb52ca18e4/e4a3f/1.png 295w,\n/static/a99b064967e9368263d4f1bb52ca18e4/fcda8/1.png 590w,\n/static/a99b064967e9368263d4f1bb52ca18e4/efc66/1.png 885w,\n/static/a99b064967e9368263d4f1bb52ca18e4/c83ae/1.png 1180w,\n/static/a99b064967e9368263d4f1bb52ca18e4/6c68b/1.png 1888w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><strong>图 1</strong> 两个 Cortex-M0 的单片机教育设备：(a) BBC micro:bit 拥有包含 16kB RAM 和 256kB 闪存的 Nordic nRF51822 微控制单元；(b) Adafruit’s Circuit Playground Express ( <a href=\"https://adafruit.com/products/3333\">https://adafruit.com/products/3333</a> ) 拥有包含 32kb RAM 和 256kB 闪存的 Atmel SAMD21 微控制单元。</p>\n<p>研究表明在计算机科学教育中使用这样的设备会增加对孩子们的吸引力，尤其是对于女生，还可以增加孩子们和老师们的自信，让课堂教学更加生动[2,16]。</p>\n<p>为了控制课堂教学的成本，这些设备一般使用 16 到 256kB 的 32 bit ARM Cortex-M 单片机，使用额外的计算机（通常是笔记本电脑或台式机）进行编程。在课堂上用这类设备进行编程教学有一系列技术挑战：</p>\n<blockquote>\n<ol>\n<li>选择/设置合适该年龄段学生的编程语言和开发环境</li>\n<li>教室的计算机使用的操作系统通常是过时的，互联网连接也不稳定或速度慢，并且可能被学校的 IT 管理员限制访问外部网络，这使得安装原生应用程序有种种困难</li>\n<li>学生开发的程序要从计算机转移到电池供电的嵌入式设备上（正如很多项目都在实验中提供这种设备，若没有提供也可以“改造”。）</li>\n</ol>\n</blockquote>\n<p>面对这些挑战，有许多流行脚本语言的嵌入式解释器应运而生，例如 JavaScript 的 JerryScript[8,15]、Duktape[22]、Espruino[23]、mJS[20]、MuJS[19]，Python 的 MicroPython[9]及其分支 CircuitPython[12]。这些解释器直接在微控制器上运行，仅依赖从计算机向嵌入式设备传输程序文本；但它们也舍弃了深度优化的 JIT 编译器（如 V8）的一些优势，这类编译器运行需要的内存比单片机的内存要大两个数量级。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/27284f7d8f183b0570238d2ea92da2f3/669eb/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.24324324324323%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAFNUlEQVQ4yx2TeVCUZQDGvyZvMgyLxKw8mnQmJ7UyPDiazKvUhFGsFFwQUJZDglRuUQivPFBTKAURFEniFDnk3F1g2ZM9WBZYjkBFG83Of5rq14t/PDPffO/M73ue93k+6cFgNw+HeoR6GR2w8/vDYU4d+xqNop5HIw5Gei1CZobtRkZ6TNzt0mBquUWPVTw7bNzr78OhqcOqbmC4pxPp/kD3U9D9fnHo6OLxXQe7ZDsoyMnml3v9DHTpGezSMWTVcd9uwpEnpynMFfPlCHpL0hj6MRFz4hxuJPtitxiQ7jmsjOlun3DSZ2Wg24S3lwfpBxN5PCK+btEyYNEwYtMzrK1n+OAsSna/ybFIHxIi/EmN+pyG6HnUxryFulWFNNw3Zt3CYLfxabwhEc/rA28OJSfwcNCGTafEpm1hWEB/UlcxHP8i70ddRDoO49L+REr8jwMRMpoPLEav0SD1WrWkpKYRHhmFn7+c4O1h7ItMIb+gjnNZ5eJ9LOs3+pJ74Syj+jp697vy9t6rSKn/MDHhEZJ8iMOBa2hO9sBkEJFt+g681vuxePlHuG/ZzTtXq1hSZWRJUz/vHMxmxXJvps9fSXJcPA+M9Zj2v86mj32Y/8FeFnnKWLgikKwtbjSkb8JmMSHZOzUEh4WxbtWHrIrP4LknIA3+gTQKTpk/4PHWbBYt8yIlPp57uhr6k2aTvXky1QGT6ZRPoErmhCJoHE3no+m3WwTQoMZ3p5yAoHAycm6y9+Ff7Bz9jS9+/Rfv8wW8u2A2zm+sRB55gCfGKnJl8zjrO51TPi9TGOjKEZ8ZXN06BfW1DBzdAtilbyUh/RTp32Rx+nw2+zOzCM24hF9qIWv9E1nutY5XFq0WwP08UJehjZ7J6U3OlMteEJrGte0ujMaOR3UjkwG7VZRiVqNUNHI2K5dd8hjWbgjA+5Molq5JYunqvSxY/ikLl60jLTWFvo468iPcSdngxgm/OWRsnknaRje+D1mCRVklNmtE6jG1YzW00dZ8h+qKH6mvvU3N7Uqqb5Vyq6KMsrIKSksrUbU0Y9RqKC8rpbAgj7If8ikvLqS48Co1lSX0i732mzuQrIZ2zCJ2d2cbFp2C2mtHUFyOpO5iOHVnd1J/xo+6kz5UHd1IRcYGak5u4/bRreQd2UPGV35UFF0Sv5wRu7EVh1ns0KIfA6qwirbbq/NpiHsV26Fp6OJEk7GzuBj2HmfC3DkV7sHxUHeKwl9DGTWBzJCFZPpJZKWH0ms10COAfWYtUqeuFZNwZhZtW+5cYfDrl9m3eS6VweM4lBiCFPsb0u4RpC//RvKtI+xDF1QJU7kudyb3s/FcObobe5dBOFTRZxKRjRoVnR0CqG2nqzGPAz5zCV49lxDPaewKD2JCGjwf8zNOKTAxUEuwpxN5oS9R8PkMzi114tvkQHoE0KpX0tupRtKrFRjULZgEUF+TQ2WEC194v0qmz7Mci9vKlIS7PL+vl6lJ95n0WSE7vKdRHODGhTWulMrHc+lwAN1mPRa9QsRuQ9K1NaNra8LY0Yq2Ogd70kSuBztTGzWF/NglRO/4iHiZJ8lBnsT4exAX5E7eHmdywl0o2fMMWcl+2EwGzOLabGItkkbVyJgMaiUt1Tf4LtiVmzsnUySbxJXIBZzwn0dN+LNURU6gLMaNpBBvDm+bTnG0K2dkLlw4HiOAejEpcW36MaDyDhplA9rWJjqU9dSX56IozUZZfhnV7esoqotoq75GW00h7bWFaOqLMTUVYWy8ibqhBH17M52iB5NWKVwq+R/xGA/Jz0X2dAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"2\"\n        src=\"/static/27284f7d8f183b0570238d2ea92da2f3/fcda8/2.png\"\n        srcset=\"/static/27284f7d8f183b0570238d2ea92da2f3/12f09/2.png 148w,\n/static/27284f7d8f183b0570238d2ea92da2f3/e4a3f/2.png 295w,\n/static/27284f7d8f183b0570238d2ea92da2f3/fcda8/2.png 590w,\n/static/27284f7d8f183b0570238d2ea92da2f3/efc66/2.png 885w,\n/static/27284f7d8f183b0570238d2ea92da2f3/c83ae/2.png 1180w,\n/static/27284f7d8f183b0570238d2ea92da2f3/669eb/2.png 1244w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><strong>图 2</strong> 三款有 160x120 分辨率彩色屏幕的基于单片机的游戏机，这些开发板使用 ARM 的 Cortex-M4F 核心：ATSAMD51G19（192kB RAM，以 120Mhz 主频运行）和 STM32F401RE（96kB RAM，以 84Mhz 主频运行）。</p>\n<p>很不幸的是，这些嵌入式解释器都比 V8 慢几个数量级（详细对比见第 4 节），影响响应速度和电池寿命。更重要的是，由于内存中的对象表示为动态键值映射（dynamic key-value mappings），因此它们的内存占用量可能是实现同样功能的 C 程序的几倍，这一点严重限制了程序在更低内存的机器上(如 16kB RAM 的 micro:bit 和 32kB RAM 的 CPX)运行的可能性。</p>\n<h3>1.1 Static TypeScript</h3>\n<p>作为上述嵌入式解释器的替代，我们开发了 Static TypeScript（STS），它是 TypeScript 的语法子集[3]，由一个用 TypeScript 编写的编译器支持，该编译器可以生成在 16-256kB RAM 的微控制器上高效运行的机器码。STS 及其编译器和运行时的设计主要着力于解决前文提到的三个挑战。确切来说：</p>\n<blockquote>\n<ul>\n<li>STS 削除了 JavaScript 大部分的「糟粕」；受 StrongScript 影响[14],对于静态声明的类，STS 使用名义类型（nominal type），并支持用虚拟函数表的经典技术对类进行高效编译。</li>\n<li>STS 工具链是离线运行的，一旦加载入浏览器，就不再需要 C/C++编译器。它们用 TypeScript 实现，将 STS 编译为 ARM Thumb 机器码并在浏览器中将其与预编译好的 C++ 运行时链接————浏览器或许在大多数时候是课堂中唯一可用的运行环境了。</li>\n<li>令人惊喜的是，STS 编译器生成的机器码高效而紧凑，使得我们解锁了一系列应用领域，例如图 2 中所示的低配置设备的游戏编程，它们能够运行全都得益于 STS 提供的能力。</li>\n</ul>\n</blockquote>\n<p>将 STS 用户程序部署到嵌入式设备不需要安装特别的应用或设备驱动，只需要进入浏览器即可。完成编译的程序以文件下载的形式显示，然后用户将文件传输到显示为 USB 存储器的设备中即可（或者直接通过 WebUSB 协议传输，它是一种即将推出的将网站与物理设备连接的协议）。</p>\n<p>STS 简单编译的编译方案（将在第 3 节详述）在一系列小型 JavaScript 基准测试中取得了惊人的优秀表现，性能可以和 V8 等先进前沿的 JIT 编译器媲美，而所需的内存则比他们低几个数量级（详情见第 4 节）；同时，也比嵌入式解释器快至少一个数量级。评估的一个特别之处是对处理类、接口和动态映射（dynamic maps）的字段/方法查找的不同策略的比较。</p>\n<h3>1.2 MakeCode：为教学而生的简单嵌入式开发</h3>\n<p>STS 是 MakeCode 框架（详情见 <a href=\"https://makecode.com\">https://makecode.com</a> ；该框架及诸多编译器已按 MIT 协议开源，请见 <a href=\"https://github.com/microsoft/pxt\">https://github.com/microsoft/pxt</a> ）支持的核心语言。MakeCode 支持为单片机设备创造自定义的嵌入式编程实验。每个 MakeCode 实验（我们一般称其为编辑器（editors），虽然它们也包含了模拟器、API、教程、文档等）通过 STS 针对特定设备或设备类型进行编程。</p>\n<p>大多数 MakeCode 编辑器主要以 Web 应用的形式部署，其中包含了用以开发 STS 程序的功能齐全的文本编辑器，它基于 Monaco（VS Code 使用的编辑器组件）；还包含了基于 Google Blockly 框架的图形化编程界面（注释中的 STS 元数据定义了 STS 的 API 到 Blockly 的映射，MakeCode 会在 Blockly 和 STS 之间进行交互）。</p>\n<p>MakeCode 编辑器和原先 BBC micro:bit 和 Adafruit CPX（详情见 <a href=\"https://makecode.microbit.org/\">https://makecode.microbit.org/</a> 和 <a href=\"https://makecode.adafruit.com/\">https://makecode.adafruit.com/</a> ）的编程实验至今已经覆盖了全球的数百万学生和教师。</p>\n<p>STS 支持包（package）的概念，即 STS、C++、汇编代码文件的集合，并支持把其他的包当做依赖。第三方开发者已经利用这样的能力对 MakeCode 编辑器进行扩展，使之可以支持各种开发板的外接设备（micro:bit 的相关示例见 <a href=\"https://makecode.microbit.org/extensions\">https://makecode.microbit.org/extensions</a> ）。值得注意的是，大多数包完全用 STS 编写从而避免了不安全 C/C++的陷阱，这主要得益于高效的 STS 编译器以及通过数/模针脚（GPIO、PWM、servos）和一些协议（I2C 和 SPI）访问硬件的底层 STS API。</p>\n<p>图 3 展示了用来为图 2 中的手持游戏设备进行编程的 MakeCode Arcade 编辑器（事实上，图中编辑器里的 STS 程序就是在三个单片机设备中运行的游戏之一，它是一个简单的平台游戏）。MakeCode Arcade 包含了一个大部分由 STS 编写的游戏引擎，因此对代码运行效率提出了很高的要求，因为要在高帧率下实现令人快活的视觉效果。该游戏引擎包含游戏循环逻辑、事件上下文栈、物理引擎、文字线条绘制等模块以及用于特定游戏的框架（比如，为图中的平台游戏（译者注：platformer games，这是一种游戏类型）），游戏引擎一共由一万行 STS 代码和少数最基础的 C++ 图像模糊函数组成。该游戏用 Arcade 构建，在浏览器（桌面或移动端）运行，或在不同型号但符合配置要求的单片机上运行（160*120 像素 16 色屏幕和 100MHz 左右主频、100kB RAM 左右的微控制器）。</p>\n<p><strong>图 3</strong> MakeCode Arcade 编辑器。左边的面板是 Arcade 设备的模拟器；中间的面板是编辑器中可用的 API 的目录；右边的面板是 Monaco 编辑器，可用在其中用 STS 代码为平台游戏编程（ <a href=\"https://makecode.com/85409-23773-98992-33605\">https://makecode.com/85409-23773-98992-33605</a> ）。位于顶部的开关用来在模块可视化编程和 Static TypeScript 编程面板之间切换（由于市场因素，被标记为 JavaScript）。</p>\n<p>本文的主要目的是详述了该广泛应用的系统和解决上述课堂教学难题的方法。</p>\n<h2>2 Static TypeScript(STS)</h2>\n<p>TypeScript[3]是 JavaScript 的渐进式[18]超集。这意味着所有 JavaScript 程序都是 TypeScript 程序并且其类型是可选的、按需添加的，这些类型可以让 IDE 提供更好的支持，也能让大型 JavaScript 程序有更好的错误检测（error checking）。对象类型提供了映射（maps）、函数和类的统一形式。对象类型之间的结构子类型（structural subtyping）定义了可替换性（substitutability）和兼容性检查。经过类型擦除（及较小的语法转换）后生成原始的 JavaScript 程序。</p>\n<p>STS 是 TypeScript 的子集，TypeScript 继承了 JavaScript 的一些高度动态化的语法：<code class=\"language-text\">with</code>语句、<code class=\"language-text\">eval</code>表达式、基于原型的集成、类之外的<code class=\"language-text\">this</code>指针、<code class=\"language-text\">arguments</code>关键字、<code class=\"language-text\">apply</code>方法。STS 保留了诸如动态映射（dynamic maps）的特性，但将它们与名义类抽象分开。这样的限制是可以接受的，因为大多数初学者编写的程序都非常简单，而且嵌入式领域的 JavaScript 或 TypeScript 库非常少，所以使用这些被限制的 JavaScript 特性（如猴子补丁，monkey patching）的机会很少。</p>\n<p>我们的目标并不是让 STS 支持 TypeScript 的全部功能，而是务实地聆听用户需求，按嵌入式编程所需添加语言特性。</p>\n<p>与所有对象类型都是属性包的 TypeScript 相比，STS 在运行时拥有四种不相关的对象类型：</p>\n<ol>\n<li><em>动态映射</em>类型，它具有命名属性（即字符串索引），能保存任何类型的值</li>\n<li><em>函数</em>（闭包）类型</li>\n<li><em>类</em>，用以描述类的示例，通过访问每个字段/方法进行高效的运行时子类型检查，对它们进行名义上的处理，后文中会详述</li>\n<li><em>数组</em>（集合）类型</li>\n</ol>\n<p>某种程度上，STS 与 Java 和 C# 的风味更接近，它们都把类型视作「抽象的守护神」（protectors of abstractions），而不像 JavaScript 那样允许更加自由地处理对象。在 3.4 节的讨论中，运行时类型标签（type tags）用于区分上面列出的不同种类的内置对象类型（以及诸如装箱数字（boxed number）和字符串之类的语言基础构件）。</p>\n<p>与 TypeScript 中一样，类型转换不会生成任何代码且不会失败。相反，STS 在字段/方法访问点保护名义上的类抽象。当<code class=\"language-text\">x == null</code>时，<code class=\"language-text\">x.f</code>在 JavaScript 中会导致运行时错误。如果<code class=\"language-text\">T</code>是具有字段<code class=\"language-text\">f</code>的类，并且<code class=\"language-text\">x</code>的动态类型不是<code class=\"language-text\">T</code>的名义子类型，则<code class=\"language-text\">(x as T).f</code>在 STS 中将导致运行时错误.如果<code class=\"language-text\">T</code>是接口，<code class=\"language-text\">any</code>或某种复杂类型（例如，union 或 intersection），则与<code class=\"language-text\">x</code>的动态类型无关，而是根据名称查找该字段。</p>\n<p>其他抽象在运行时中也受到保护，正如在 JavaScript 中那样：例如，对非<em>函数</em>类型的对象进行函数调用。现在，将属性动态添加到除<code class=\"language-text\">map</code>类型之外的任何其他类型是错误的。我们将来可能会取消对动态 JavaScript 语义的限制，这取决于用户的反馈。迄今为止，在我们的用户社区（教育工作者和开发人员）中还没有收到任何关于这些限制的负面反馈。</p>\n<p>STS 基本类型根据 JavaScript 语义进行处理。特别要强调的是，所有的数字类型在理论上都是 IEEE 64 位浮点类型，但也有可能实际使用 31 位带符号标记的整数类型。运算符的实现（例如加法或比较）基于动态值的分支，以遵循 JavaScript 语义，并在汇编中手动实现了整数类型的快速实现。</p>\n<p>STS 既是 TypeScript 的语法子集又是语义子集，这意味着，如果程序在 STS 中成功编译，它将具有与等效 TypeScript 程序相同的语义，否则它无法完成编译（？）。</p>\n<h3>2.1 与 C++ 进行交互操作</h3>\n<p>STS 程序运行在单片机上由 C++、C、汇编实现的运行时里。该运行时实现了语言的基础构件（操作符、集合、类的支持、动态映射等），同样也支持对底层硬件的访问。该运行时能被包集成，相关详情见 2.2 节。</p>\n<p>STS 支持调用 C++ 函数，反之，亦可以从 C++ 调用 STS 函数。为了简化这个过程，STS 使用了一直能够简单的代码生成策略，即在 C++ 函数中使用特殊的注释（<code class=\"language-text\">//%</code>）指定那些代码需要导出为 STS，这样的策略还用于导出为 Blockly 代码块（使用注释<code class=\"language-text\">//% block</code>）。构建中有一个步骤是解析 C++代码获取这些特殊的注释，还会收集这些函数的原型（签名），从而在调用它们时可以生成正确的转换。举个转换的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// C++源码:</span>\n<span class=\"token keyword\">namespace</span> control <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/** Register an event handler */</span>\n    <span class=\"token comment\">//% block</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">onEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> eventType<span class=\"token punctuation\">,</span> Action handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// arrange for pxt::runAction0(handler)</span>\n        <span class=\"token comment\">// to be called when eventType is triggered</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 生成的TypeScript</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">namespace</span> control <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** Register an event handler */</span>\n  <span class=\"token comment\">//% block shim=control::onEvent</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">onEvent</span><span class=\"token punctuation\">(</span>eventType<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>C++ 的命名空间和函数名直接映射到 STS 对等的代码上，原先的代码文档注释也会对应复制。注释<code class=\"language-text\">//% block</code>指定函数暴露为 Blockly 图形代码块，它也会被复制。还有许多其它可能的注释可以控制等效图形的外观。STS 函数还会有一个附加的<code class=\"language-text\">shim</code>注释，标注对应的 C++ 函数名（某些情况下，STS 声明是用用户编写的，这时候 C++ 函数名不必与 STS 函数名对应）。\nC++ 的类型会映射到 STS 的类型，由于在 STS 中所有数字类型理论上都是双精度的（），所以 C ++ 的<code class=\"language-text\">int</code>类型会映射到 STS 的<code class=\"language-text\">number</code>类型。当 C++ 函数被调用时，STS 编译器会确保被传递的值被转换为整数。其它的 C++ 整数类型（例如<code class=\"language-text\">uint16_t</code>）也用相似的方法被支持。C++的<code class=\"language-text\">Action</code>类型代表对一个闭包的引用，它将和<code class=\"language-text\">pxt::runAction0（）</code>一起被调用。</p>\n<p>类方法还没有被直接支持，常规的函数能用于实现对象，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span> BoxedBuffer <span class=\"token operator\">*</span>Buffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">namespace</span> BufferMethods <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//%</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">getByte</span><span class=\"token punctuation\">(</span>Buffer self<span class=\"token punctuation\">,</span> <span class=\"token keyword\">uint32_t</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> i <span class=\"token operator\">&lt;</span> self<span class=\"token operator\">-></span>len <span class=\"token operator\">?</span> self<span class=\"token operator\">-></span>data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Buffer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//% shim=BufferMethods::getByte</span>\n  <span class=\"token function\">getByte</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>所有在<code class=\"language-text\">BufferMethods</code>命名空间中的函数都必须将<code class=\"language-text\">Buffer</code>作为第一个参数，并在 STS 这边作为<code class=\"language-text\">Buffer</code>类的成员。当这些成员被调用时，STS 编译器会确认第一个参数不是<code class=\"language-text\">null</code>并且是<code class=\"language-text\">Foo</code>的子类型。这些接口在概念上可以理解为具有不透明表示形式的不可扩展类，即它们不能由常规类实现，并且成员解析是静态的（static）。选择接口语法是因为 TypeScript 允许用新方法在文件之间扩展接口。如果新方法具有上述的<code class=\"language-text\">shim = ...</code>注释，或者指定了使用 TypeScript 而不是 C ++替换函数的模拟注释，那么我们允许此类添加。。这通常只在高级 C++ 包的开发中涉及（见下文）。</p>\n<h3>2.2 包（Packages）</h3>\n<p>STS 支持多种输入文件，也支持 TypeScript 的<code class=\"language-text\">namespace</code>语法用以区分作用域。文件不会引入作用域，并且当前不支持 JavaScript 模块。输入文件可以来自一个或多个<em>包</em>。其中一个包为主包，可以列出其他包作为依赖关系，而后者又可以列出其他的依赖关系。有多种方法可以指定包的版本，包括内置包、用命令行进行操作时指定文件路径、GitHub 仓库的 URL。使用包时只能用一个版本（否则可能会发生重定义错误）。</p>\n<p>MakeCode 编辑器的构建者通常会决定打包一些随编辑器提供的内置包，这些扩展可以通过 GitHub 中的包进一步扩展。 MakeCode Web 应用程序支持将包发布到 GitHub。 因为命名空间独立于文件，所以包很容易扩展现有的命名空间。目前，STS 不对命名空间名称执行检查。</p>\n<p>MakeCode 附带了许多编辑器构建器可以附带的包（通用包），它们用以支持各种硬件功能（引脚、按钮、蜂鸣器、屏幕等），以及诸如处理 Spite 的游戏库之类的高级概念。其中一些包是变体，共享界面但具有不同的实现方式（例如，用于不同屏幕的驱动程序）。</p>\n<p>外部（GitHub）包通常为其他硬件拓展设备提供支持。用户通常不会一次使用太多外部包，因此我们感到由于没有让命名空间强制不同名而导致名称冲突的风险很低，并且它允许将新的 API 自然地适合现有的名称空间。</p>\n<h2>3 编译器和运行时</h2>\n<p>STS 的编译器和工具链（链接器等）完全使用 TypeScript 编写。现在尚不支持单独编译 STS 文件，STS 是一个完整的程序编译器（支持缓存预编译的包，其中包含了 C++ 运行时）。STS 的设备运行时主要是由 C++ 编写的，包含定制的垃圾回收器。正如前文提到的，STS 并不计划支持 JavaScript 的全部功能。</p>\n<h3>3.1 编译工具链</h3>\n<p>TypeScript 源程序由常规 TypeScript 编译器处理，执行包块类型检查在内的语法和语义分析；这个过程产出有类型注释的抽象语法树（AST），然后检查是否有 STS 范围之外的构造（类似<code class=\"language-text\">eval</code>和<code class=\"language-text\">arguments</code>等）。抽象语法树随后会转化为具有语言构造的自定义 IR 用以调用运行时函数。这种 IR 之后回北转换为下列的三种形式之一：</p>\n<ol>\n<li>继续传递 JavaScript 运行到浏览器中（在单独的 iframe“模拟器”里）。</li>\n<li>与预编译的 C++ 运行时链接的 ARM Thumb 机器码，用以在裸机（A ‘bare-metal server’ is a computer server that is a ‘single-tenant physical server’. The term is used nowadays to distinguish it from modern forms of virtualisation and cloud hosting.）硬件和操作系统内部运行。</li>\n<li>自定义虚拟机的字节码，用于无法加载或生成动态语言的平台（例如 XBox 和 iOS）。</li>\n</ol>\n<p>ARM Thumb 机器码和自定义的字节码全都被生成为汇编代码，再由定制的汇编器转换为机器码。在本节中我们主要讨论原生 32-bit ARM Thumb 的转化过程（我们会在 4.2 节对比虚拟机的性能）。</p>\n<p>本段提到的常规的 TypeScript 编译器、STS 代码生成器、汇编器（assembler）、链接器（linker）均由 TypeScript 实现并且全部运行在浏览器或命令行中。</p>\n<h3>3.2 链接</h3>\n<p>生成的机器码将与一个预编译的 C++ 运行时链接。C++ 的编译在云上运行，编译生成的运行时缓存在 CDN 和浏览器中（可以选择使用所有 C++源码的强哈希算法进行缓存）。通常来说，用户编写他们的程序时，C++ 运行时不会更改，从而让离线操作成为可能[5]。</p>\n<p>生成的机器码通常会附加在预编译 C++ 运行时代码的后面，根据目标设备要求的文件格式（特别是 ELF）对生成文件进行一些修补。为了生成代码，汇编器需要运行时函数的地址，这些地址从运行时的二进制文件提取。</p>\n<p>包可能还要包含从运行时中继承出来的 C++ 代码。包含 C++ 的包组合都必须分别进行编译和缓存，这些也都是在云上运行的。到目前为止，这些可能是天量数字的包组合方式还没有出现大问题，因为学生一般不会一次使用很多外部的包，而且我们的经验是，为 MakeCode 编写的包很少使用原生 C++。</p>\n<h3>3.5 算术运算符</h3>\n<p>一些算术运算符被编写为快速整数路径的汇编提高运行速度；以下是运算符<code class=\"language-text\">+</code>的实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">_numops_adds:\n    ands r2, r0, r1 ; r2 := r0 &amp; r1\n    ands r2, #1 ; r2 &amp;= 1\n    beq .boxed ; last bit clear?\n    subs r2, r1, #1 ; r2 := r1 - 1\n    adds r2, r0, r2 ; r2 := r0 + r2\n    bvs .boxed ; overflow?\n    mov r0, r2 ; r0 := r2\n    bx lr ; return\n.boxed:\n    mov r4, lr ; save return address\n    bl numops::adds ; call into runtime\n    bx r4 ; return</code></pre></div>\n<p>其它由特别实现的算术运算符有<code class=\"language-text\">-</code>、<code class=\"language-text\">|</code>、<code class=\"language-text\">&amp;</code>、<code class=\"language-text\">^</code>和整数转换（调用 C++ 运行时函数时使用）。这些特别的汇编程序比始终调用 C++ 函数要快约两倍。我们在 4.3 节对乘法的性能做了比较。\n除此之外的运算符则用 C++ 实现为使用整数、限制范围的数值和其它类型的抽象值的函数。</p>\n<h3>3.6 内置对象（built-in）的表示</h3>\n<p><strong>数组（Arrays）</strong> 和 C++标准向量（vector）类似，但有相对保守的增长策略并且不支持稀疏数组（sparse array）。包括范围检查在内的简单数组访问操作用用汇编实现。设计索引转换和数组增长的情况用 C++ 运行时处理。缓冲区只是具有汇编字节访问器和用 C ++ 实现的许多实用程序函数的内存连续块。</p>\n<p><strong>字符串（Strings）</strong> 会有四种不同的表示，它们的开头都毁有一个虚函数表（v-table）指针。所有的字符串当前被限制为最大占用 65,535 字节的空间。ASCII 字符串（所有在 0-127 范围内的字符）用长度前缀加 NUL 中止的字符数据表示（其内部仍然可以有 NUL，只是为了方便 C++ 函数使用所以添加最后的 NUL）。较短的 Unicode 字符串使用 UTF-8 的可变长度编码，它们拥有不同的虚函数表。索引方法可以即时解码 UTF-8。</p>\n<h3>3.7 窥孔优化</h3>\n<h3>3.8 垃圾回收器</h3>\n<h2>4 性能评估</h2>\n<p>我们在一系列著名的小型性能密集型测试基准中评估了 STS 编译生成的机器码（又可以成为 STS 的虚拟机后端）的性能，并与以下的竞争对手做了对比：</p>\n<ul>\n<li>一种用 gcc 编译的纯 C 实现，用来做对比实验的基准（baseline）</li>\n<li><strong>Duktape 2.3</strong>，一种嵌入式 JavaScript 解释器</li>\n<li><strong>IoT.js 1.0</strong>，JerryScript 的嵌入式 JavaScript 解释器</li>\n<li><strong>Python 3.6</strong>，寻常、成熟的 Python 解释器</li>\n<li><strong>Node.js 11.0</strong>，包含了 V8 这种前沿的 JIT 引擎的运行时</li>\n<li><strong>MicroPython 1.9.4</strong>，一种嵌入式 Python 解释器</li>\n</ul>\n<p>我们使用三种不同的基于 ARM 的商用嵌入式系统进行测试：</p>\n<ul>\n<li><strong>GHI Brainpad</strong>，使用 STM32F401RE 芯片, 拥有 96kB RAM、512kB 闪存和主频为 84MHz 的 ARM Cortex-M4F 核心。</li>\n<li><strong>Adafruit Pybadge</strong>，使用 ATSAMD51G19 芯片，拥有 192kB RAM、512kB 闪存和主频为 120MHz 的 ARM Cortex-M4F 核心。</li>\n<li><strong>树莓派 Zero（Raspberry Pi Zero）</strong>，使用 BCM2835 芯片，拥有 512kB RAM 和恒定主频为 700MHz （关闭动态 CPU 主频调整）的 ARM11 核心。</li>\n</ul>\n<p>树莓派可以运行 Node.js，所以超出了我们目标的内存范围，但我们使用它来作为 V8 的性能参考。通常来说，ARM11 核心的内存访问比 M4F 核心（整体 RAM 在性能上与 L1 缓存类似）的访问速度慢。M4F 核心上的 FPU 只是单精度的，所以么有用于基准测试。我们使用了 ARM11 上的 FPU。</p>\n<p>Duktape 使用 BCM 上的默认配置进行编译。在 STM 上，使用默认配置会立即耗尽内存，所以我们选用了适用于低内存配置文件（还启用了 fast integer 选项）。我们用的是官方的 ARMv6 Node.js 二进制文件。我们使用了 PiCore Linux 附带的 Python 环境。我们用过。我们使用了 STM32 的官方 MicroPython 二进制文件。</p>\n<h2>4.1 基准测试</h2>\n<p>我们使用下面的一系列基准测试。我们尝试使用在 TypeScript/JavaScript 和 Python 中对等的代码，然后对比运行时间</p>\n<h2>4.2 STS 和 VM 的性能</h2>\n<p>图 4 对比了 STS 和其他环境的性能。我们将 C 程序的运行耗时直接用毫秒列出，其他的耗时则以比 C 程序慢多少的差值列出，以表示对 C 的敬意。</p>\n<h2>5 相关的工作</h2>\n<p>Safe TypeScript[13]和 StrongScript[14]都通过运行时类型检查支持了完整的 TypeScript 的类型系统。我们的工作最接近 StrongScript，因为 STS 使用类的名义解释（nominal interpretation）进行代码生成，且 STS 运行时会区分动态对象和类对象，分别生成 JavaScript 的<code class=\"language-text\">{x=...}</code>语法和<code class=\"language-text\">new C(...)</code>语法。</p>\n<p>STS 和 StrongScript 也有一些区别，首先，StrongScript 的类型</p>\n<h2>6 总结</h2>\n<p>Static TypeScript（STS）填补了嵌入式编译器中有趣的空白。STS 的工具链完全由 TypeScript 实现，使之可以在浏览器运行并能为覆盖大部分 TypeScript 功能的子集成成 ARM（Thumb）机器码。STS 利用类的名义类型解释（nominal interpretation）提高编译代码的效率。有赖于 MakeCode，STS 现已广泛运行在许多低 RAM 的设备上。一组对 STS 的小型基准评估表明，STS 生成的代码比各种脚本语言的嵌入式解释器的运行速度要快得多。迄今为止最大的 STS 应用程序是 MakeCode Arcade，其游戏引擎有超过 10,000 行 STS 代码。</p>\n<p><strong>致谢</strong> 我们要感谢 MakeCode 团队的成员和前成员：Abhijith Chatra、Sam El-Husseini、Caitlin Hennessy、Steve Hodges、Guillaume\nJenkins、Shannon Kao、Richard Knoll、Jacqueline Russell、Daryl Zuniga。我们还要感谢 Lancaster 大学的 James Devine 和 Joe Finney，他们开发的 CODAL 是 STS 的 C++运行时的一部分。最后，我们还要感谢匿名审稿人的评论，并感谢 Edd Barrett 帮忙润色本文的最终版本。</p>\n<hr>\n<p>[1]: Jonny Austin, Howard Baker, Thomas Ball, James Devine, Joe Finney,Peli de Halleux, Steve Hodges, Michal Moskal, and Gareth Stockdale. 2019. The BBC micro:bit – from the UK to the World. Commun. ACM(to appear) (2019).</p>\n<p>[2]: BBC. 2017. BBC micro:bit celebrates huge impact in first year, with 90% of students saying it helped show that anyone can code. <a href=\"https://www.bbc.co.uk/mediacentre/latestnews/2017/microbit-first-year\">https://www.bbc.co.uk/mediacentre/latestnews/2017/microbit-first-year</a>.</p>\n<p>[3]: Gavin M. Bierman, Martín Abadi, and Mads Torgersen. 2014. Understanding TypeScript. In ECOOP 2014 - Object-Oriented Programming - 28th European Conference, Uppsala, Sweden, July 28 - August 1, 2014.Proceedings. 257–281. <a href=\"https://doi.org/10.1007/978-3-662-44202-9_11\">https://doi.org/10.1007/978-3-662-44202-9_11</a></p>\n<p>[5]: 尽管我们可以使用 Emscripten 或类似的技术在本地对 C++ 进行编译，但编译工具链、头文件和相关的库可能需要数十兆的下载请求，导致浏览器的离线缓存空间紧张。</p>\n<hr>","frontmatter":{"title":"译文：Static TypeScript，TypeScript 的一种静态编译器实现","date":"November 23, 2020","description":"TypeScript 的一种静态编译器实现"}}},"pageContext":{"slug":"/static-ts/","previous":{"fields":{"slug":"/ml-writing-compilers/"},"frontmatter":{"title":"译文：为什么 ML/OCaml 适用于编译器开发（1998）"}},"next":null}},"staticQueryHashes":["2841359383"]}